# Sprint 6.4: AI Self-Review Pipeline

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add quality review, rewrite loop, and polish stages to AI post generation - transforming single-shot generation into a multi-stage pipeline that produces higher quality, less "AI-sounding" content.

**Architecture:** Extend the existing queue worker to process post_generation jobs through 3 additional stages: REVIEW (score quality, identify issues), REWRITE (fix issues, max 2 loops), and POLISH (final grammar/language pass). Each stage is a separate LLM call with specialized prompts.

**Tech Stack:** TypeScript, existing Ollama Cloud integration, existing queue worker, Croatian banned words list

**Reference:** Based on 6-stage pipeline from `/home/wandeon/GenAI/docs/6-stage-article-pipeline-guide.md`

---

## Overview

Current flow:
```
User Instructions → WRITE → Done
```

New flow:
```
User Instructions → WRITE → REVIEW → (REWRITE loop) → POLISH → Done
                              ↓           ↑
                         Issues? ─────────┘
                         (max 2x)
```

---

## Task 1: Create Croatian Banned Words & Review Types

**Files:**
- Create: `apps/admin/lib/ai/prompts/banned-words.ts`
- Create: `apps/admin/lib/ai/prompts/types.ts`

**Step 1: Create the types file**

Create `apps/admin/lib/ai/prompts/types.ts`:

```typescript
/**
 * Types for AI self-review pipeline
 * Based on 6-stage article generation pipeline
 */

// =============================================================================
// Review Types
// =============================================================================

export interface ReviewScores {
  clarity: number;        // 1-10: Is it clear what the article is about?
  localRelevance: number; // 1-10: Connected to Veliki Bukovec/local readers?
  slopScore: number;      // 1-10: Free from AI-speak? (10 = no slop)
  flow: number;           // 1-10: Reads naturally, good structure?
}

export interface ReviewIssue {
  type:
    | 'slop_word'          // Banned word detected
    | 'slop_phrase'        // AI-sounding phrase
    | 'sentence_too_long'  // >30 words
    | 'wall_of_text'       // >5 sentences in paragraph
    | 'missing_local'      // No connection to local context
    | 'missing_concrete'   // Vague without specifics
    | 'grammar';           // Grammar/spelling issue
  location: string;        // e.g., "paragraph 2" or "title"
  text?: string;           // The problematic text
  fix: string;             // Specific instruction how to fix
}

export interface ReviewResult {
  scores: ReviewScores;
  overall: number;         // Average of scores
  pass: boolean;           // true if overall >= 7.0
  issues: ReviewIssue[];   // Specific problems to fix
}

// =============================================================================
// Pipeline Configuration
// =============================================================================

export const PIPELINE_CONFIG = {
  qualityThreshold: 7.0,   // Minimum overall score to pass
  maxRewriteAttempts: 2,   // Max rewrite loops before proceeding
  maxSentenceWords: 30,    // Sentences longer than this get flagged
  maxParagraphSentences: 5, // Paragraphs with more sentences get flagged
} as const;
```

**Step 2: Create the banned words file**

Create `apps/admin/lib/ai/prompts/banned-words.ts`:

```typescript
/**
 * Croatian Banned Words List
 * Articles containing these words/phrases will be flagged for rewrite
 *
 * Categories:
 * - AI buzzwords (Croatian translations)
 * - Filler phrases that add no value
 * - Overly formal/bureaucratic language
 * - English buzzwords that shouldn't appear
 */

// =============================================================================
// Banned Words (Single Words)
// =============================================================================

export const BANNED_WORDS = [
  // AI buzzwords (Croatian)
  'revolucionarno',
  'revolucionaran',
  'transformativno',
  'transformativan',
  'inovativan',
  'inovativno',
  'krajobraz',           // "landscape" used metaphorically
  'putovanje',           // "journey" used metaphorically
  'sinergija',
  'optimizirati',
  'leverirati',          // anglicism
  'implementirati',      // prefer "provesti" or "uvesti"

  // English buzzwords (should not appear in Croatian text)
  'game-changing',
  'cutting-edge',
  'state-of-the-art',
  'unprecedented',
  'groundbreaking',
  'revolutionary',
  'transformative',
  'innovative',
  'leverage',
  'synergy',
  'paradigm',
  'holistic',
  'robust',
  'seamless',
  'streamline',
] as const;

// =============================================================================
// Banned Phrases
// =============================================================================

export const BANNED_PHRASES = [
  // Filler phrases (Croatian)
  'u današnjem svijetu',
  'u svijetu koji se stalno mijenja',
  'nije tajna da',
  'važno je napomenuti',
  'vrijedi spomenuti',
  'kao što svi znamo',
  'bez sumnje',
  'naravno',
  'zapravo',
  'u biti',
  'u konačnici',
  'na kraju krajeva',
  'sve u svemu',
  'jednostavno rečeno',
  'drugim riječima',

  // Overly formal openings
  'ovim putem',
  's poštovanjem',
  'drago nam je',
  'sa zadovoljstvom',

  // AI-style transitions
  'štoviše',
  'nadalje',
  'osim toga',
  'u tom kontekstu',
  'u tom smislu',
  's tim u vezi',

  // Vague value statements
  'iznimno važno',
  'od velike važnosti',
  'ključno je',
  'bitno je naglasiti',
  'posebno treba istaknuti',
] as const;

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Check if text contains any banned words
 * Returns array of found banned words
 */
export function findBannedWords(text: string): string[] {
  const lowerText = text.toLowerCase();
  const found: string[] = [];

  for (const word of BANNED_WORDS) {
    if (lowerText.includes(word.toLowerCase())) {
      found.push(word);
    }
  }

  return found;
}

/**
 * Check if text contains any banned phrases
 * Returns array of found banned phrases
 */
export function findBannedPhrases(text: string): string[] {
  const lowerText = text.toLowerCase();
  const found: string[] = [];

  for (const phrase of BANNED_PHRASES) {
    if (lowerText.includes(phrase.toLowerCase())) {
      found.push(phrase);
    }
  }

  return found;
}

/**
 * Check all banned content and return combined results
 */
export function findAllBanned(text: string): { words: string[]; phrases: string[] } {
  return {
    words: findBannedWords(text),
    phrases: findBannedPhrases(text),
  };
}
```

**Step 3: Run type-check**

```bash
pnpm type-check
```

**Step 4: Commit**

```bash
git add apps/admin/lib/ai/prompts/
git commit -m "feat(ai): add Croatian banned words list and review types"
```

---

## Task 2: Create Review Prompt

**Files:**
- Create: `apps/admin/lib/ai/prompts/review.ts`

**Step 1: Create the review prompt**

Create `apps/admin/lib/ai/prompts/review.ts`:

```typescript
/**
 * Review Stage Prompt
 * Scores article quality and identifies specific issues to fix
 */

import { BANNED_PHRASES, BANNED_WORDS } from './banned-words';
import { PIPELINE_CONFIG, type ReviewResult } from './types';

// =============================================================================
// System Prompt
// =============================================================================

export const REVIEW_SYSTEM_PROMPT = `Ti si kontrolor kvalitete za članke Općine Veliki Bukovec.
Tvoj zadatak je ocijeniti kvalitetu članka i identificirati konkretne probleme.

PRAVILA OCJENJIVANJA (1-10):
- clarity (jasnoća): Je li jasno o čemu članak govori? 10 = kristalno jasno
- localRelevance (lokalna relevantnost): Je li povezano s Velikim Bukovcem? 10 = izravno relevantno
- slopScore (AI-govor): Je li tekst prirodan? 10 = zvuči potpuno ljudski, 1 = očito AI
- flow (tečnost): Čita li se glatko? 10 = izvrsna struktura i prijelazi

ZABRANJENE RIJEČI (članak PADA ako ih sadrži):
${BANNED_WORDS.slice(0, 15).join(', ')}

ZABRANJENE FRAZE (članak PADA ako ih sadrži):
${BANNED_PHRASES.slice(0, 10).join('; ')}

TIPOVI PROBLEMA:
- slop_word: Pronađena zabranjena riječ
- slop_phrase: Pronađena AI-tipična fraza
- sentence_too_long: Rečenica ima više od ${PIPELINE_CONFIG.maxSentenceWords} riječi
- wall_of_text: Odlomak ima više od ${PIPELINE_CONFIG.maxParagraphSentences} rečenica
- missing_local: Nedostaje poveznica s lokalnom zajednicom
- missing_concrete: Previše neodređeno, nedostaju konkretni podaci
- grammar: Gramatička ili pravopisna greška

VAŽNO: Svaki problem MORA imati konkretnu uputu za popravak!
- LOŠE: "Poboljšaj tečnost"
- DOBRO: "Podijeli rečenicu u odlomku 3 nakon 'međutim' - trenutno ima 35 riječi"

Odgovori ISKLJUČIVO u JSON formatu.`;

// =============================================================================
// User Prompt Builder
// =============================================================================

export function buildReviewUserPrompt(article: {
  title: string;
  content: string;
  excerpt: string;
}): string {
  return `Ocijeni ovaj članak za web stranicu Općine Veliki Bukovec:

NASLOV:
${article.title}

SAŽETAK:
${article.excerpt}

SADRŽAJ:
${article.content}

---

Odgovori u JSON formatu:
{
  "scores": {
    "clarity": <1-10>,
    "localRelevance": <1-10>,
    "slopScore": <1-10>,
    "flow": <1-10>
  },
  "overall": <prosjek ocjena>,
  "pass": <true ako overall >= ${PIPELINE_CONFIG.qualityThreshold}>,
  "issues": [
    {
      "type": "<tip problema>",
      "location": "<gdje se nalazi, npr. 'odlomak 2' ili 'naslov'>",
      "text": "<problematični tekst ako je primjenjivo>",
      "fix": "<KONKRETNA uputa za popravak>"
    }
  ]
}

Ako nema problema, issues neka bude prazan array [].`;
}

// =============================================================================
// Response Parser
// =============================================================================

export function parseReviewResponse(response: string): ReviewResult | null {
  try {
    // Extract JSON from response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    const parsed = JSON.parse(jsonMatch[0]) as unknown;

    // Validate structure
    if (
      typeof parsed !== 'object' ||
      parsed === null ||
      !('scores' in parsed) ||
      !('overall' in parsed) ||
      !('pass' in parsed) ||
      !('issues' in parsed)
    ) {
      return null;
    }

    const result = parsed as ReviewResult;

    // Validate scores exist
    if (
      typeof result.scores.clarity !== 'number' ||
      typeof result.scores.localRelevance !== 'number' ||
      typeof result.scores.slopScore !== 'number' ||
      typeof result.scores.flow !== 'number'
    ) {
      return null;
    }

    return result;
  } catch {
    return null;
  }
}
```

**Step 2: Run type-check**

```bash
pnpm type-check
```

**Step 3: Commit**

```bash
git add apps/admin/lib/ai/prompts/review.ts
git commit -m "feat(ai): add review stage prompt for quality scoring"
```

---

## Task 3: Create Rewrite Prompt

**Files:**
- Create: `apps/admin/lib/ai/prompts/rewrite.ts`

**Step 1: Create the rewrite prompt**

Create `apps/admin/lib/ai/prompts/rewrite.ts`:

```typescript
/**
 * Rewrite Stage Prompt
 * Fixes ONLY the identified issues, preserves everything else
 */

import type { ReviewIssue } from './types';

// =============================================================================
// System Prompt
// =============================================================================

export const REWRITE_SYSTEM_PROMPT = `Ti si urednik koji popravlja specifične probleme u članku.

VAŽNA PRAVILA:
1. Popravi SAMO navedene probleme - ništa drugo ne mijenjaj
2. Zadrži istu strukturu i HTML tagove
3. Zadrži isti ton i stil
4. Zadrži sve činjenice i podatke
5. NE dodaj nove odlomke ili sekcije
6. NE uklanjaj sadržaj osim ako to nije dio popravka

Tvoj zadatak je minimalna intervencija - popravi problem i ostavi sve ostalo.

Odgovori ISKLJUČIVO u JSON formatu s istom strukturom kao ulaz.`;

// =============================================================================
// User Prompt Builder
// =============================================================================

export function buildRewriteUserPrompt(
  article: { title: string; content: string; excerpt: string },
  issues: ReviewIssue[]
): string {
  const issuesList = issues
    .map((issue, i) => {
      let description = `${i + 1}. [${issue.type}] u "${issue.location}"`;
      if (issue.text) {
        description += `\n   Tekst: "${issue.text}"`;
      }
      description += `\n   Popravak: ${issue.fix}`;
      return description;
    })
    .join('\n\n');

  return `Popravi sljedeće probleme u članku:

PROBLEMI ZA POPRAVAK:
${issuesList}

---

TRENUTNI ČLANAK:

NASLOV:
${article.title}

SAŽETAK:
${article.excerpt}

SADRŽAJ:
${article.content}

---

Odgovori u JSON formatu s popravljenim člankom:
{
  "title": "<popravljeni naslov>",
  "content": "<popravljeni sadržaj>",
  "excerpt": "<popravljeni sažetak>"
}

NAPOMENA: Popravi SAMO navedene probleme. Zadrži sve ostalo nepromijenjeno.`;
}
```

**Step 2: Run type-check**

```bash
pnpm type-check
```

**Step 3: Commit**

```bash
git add apps/admin/lib/ai/prompts/rewrite.ts
git commit -m "feat(ai): add rewrite stage prompt for fixing issues"
```

---

## Task 4: Create Polish Prompt

**Files:**
- Create: `apps/admin/lib/ai/prompts/polish.ts`

**Step 1: Create the polish prompt**

Create `apps/admin/lib/ai/prompts/polish.ts`:

```typescript
/**
 * Polish Stage Prompt
 * Final language quality pass - grammar, spelling, natural phrasing
 */

// =============================================================================
// System Prompt
// =============================================================================

export const POLISH_SYSTEM_PROMPT = `Ti si hrvatski lektor koji radi završnu korekturu članka.

TVOJ ZADATAK:
1. Ispravi sve pravopisne greške
2. Ispravi sve gramatičke greške
3. Poboljšaj nespretne formulacije (ali zadrži značenje)
4. Osiguraj dosljednost interpunkcije

PRAVILA:
- Ovo NIJE prepisivanje - samo korektura
- NE mijenjaj sadržaj ili strukturu
- NE dodaj nove rečenice ili odlomke
- NE uklanjaj sadržaj
- Zadrži sve HTML tagove točno kako jesu
- Koristi hrvatski pravopis (ijekavica)

Odgovori ISKLJUČIVO u JSON formatu s istom strukturom kao ulaz.`;

// =============================================================================
// User Prompt Builder
// =============================================================================

export function buildPolishUserPrompt(article: {
  title: string;
  content: string;
  excerpt: string;
}): string {
  return `Napravi završnu korekturu ovog članka:

NASLOV:
${article.title}

SAŽETAK:
${article.excerpt}

SADRŽAJ:
${article.content}

---

Odgovori u JSON formatu s korigiranim člankom:
{
  "title": "<korigirani naslov>",
  "content": "<korigirani sadržaj>",
  "excerpt": "<korigirani sažetak>"
}

NAPOMENA: Ovo je korektura, ne prepisivanje. Ispravi samo greške, zadrži sve ostalo.`;
}
```

**Step 2: Create index file for prompts**

Create `apps/admin/lib/ai/prompts/index.ts`:

```typescript
// Types
export * from './types';

// Banned words
export * from './banned-words';

// Stage prompts
export * from './review';
export * from './rewrite';
export * from './polish';
```

**Step 3: Run type-check**

```bash
pnpm type-check
```

**Step 4: Commit**

```bash
git add apps/admin/lib/ai/prompts/
git commit -m "feat(ai): add polish stage prompt and prompts index"
```

---

## Task 5: Create Pipeline Processor

**Files:**
- Create: `apps/admin/lib/ai/pipeline.ts`

**Step 1: Create the pipeline processor**

Create `apps/admin/lib/ai/pipeline.ts`:

```typescript
/**
 * AI Article Pipeline
 * Processes articles through REVIEW → REWRITE → POLISH stages
 */

import { aiLogger } from '../logger';
import { generate } from './ollama-cloud';
import {
  buildPolishUserPrompt,
  buildReviewUserPrompt,
  buildRewriteUserPrompt,
  findAllBanned,
  parseReviewResponse,
  PIPELINE_CONFIG,
  POLISH_SYSTEM_PROMPT,
  REVIEW_SYSTEM_PROMPT,
  REWRITE_SYSTEM_PROMPT,
} from './prompts';

import type { ReviewIssue, ReviewResult } from './prompts';

// =============================================================================
// Types
// =============================================================================

interface Article {
  title: string;
  content: string;
  excerpt: string;
}

interface PipelineResult {
  article: Article;
  reviewHistory: ReviewResult[];
  rewriteCount: number;
  finalScore: number;
  passed: boolean;
}

// =============================================================================
// Pipeline Stages
// =============================================================================

/**
 * Pre-check for banned words/phrases before LLM review
 * Returns issues that can be detected without LLM
 */
function preCheck(article: Article): ReviewIssue[] {
  const issues: ReviewIssue[] = [];
  const fullText = `${article.title} ${article.excerpt} ${article.content}`;

  const banned = findAllBanned(fullText);

  for (const word of banned.words) {
    issues.push({
      type: 'slop_word',
      location: 'članak',
      text: word,
      fix: `Zamijeni riječ "${word}" s konkretnim opisom`,
    });
  }

  for (const phrase of banned.phrases) {
    issues.push({
      type: 'slop_phrase',
      location: 'članak',
      text: phrase,
      fix: `Ukloni frazu "${phrase}" ili je zamijeni konkretnom informacijom`,
    });
  }

  return issues;
}

/**
 * REVIEW stage: Score article and identify issues
 */
async function reviewArticle(article: Article): Promise<ReviewResult> {
  // First do pre-check for banned words
  const preCheckIssues = preCheck(article);

  // Call LLM for full review
  const prompt = buildReviewUserPrompt(article);
  const result = await generate(prompt, { system: REVIEW_SYSTEM_PROMPT });

  if (!result.success) {
    aiLogger.error({ error: result.error }, 'Review stage failed');
    // Return a failing review with pre-check issues
    return {
      scores: { clarity: 5, localRelevance: 5, slopScore: 5, flow: 5 },
      overall: 5,
      pass: false,
      issues: preCheckIssues.length > 0 ? preCheckIssues : [{
        type: 'grammar',
        location: 'članak',
        fix: 'Pregledaj članak i ispravi moguće probleme',
      }],
    };
  }

  const parsed = parseReviewResponse(result.data.response);

  if (!parsed) {
    aiLogger.warn('Failed to parse review response');
    return {
      scores: { clarity: 5, localRelevance: 5, slopScore: 5, flow: 5 },
      overall: 5,
      pass: false,
      issues: preCheckIssues,
    };
  }

  // Merge pre-check issues with LLM issues
  const allIssues = [...preCheckIssues, ...parsed.issues];

  // If we found banned words, force fail
  if (preCheckIssues.length > 0) {
    parsed.pass = false;
    // Reduce slop score if banned words found
    parsed.scores.slopScore = Math.min(parsed.scores.slopScore, 4);
    parsed.overall = (
      parsed.scores.clarity +
      parsed.scores.localRelevance +
      parsed.scores.slopScore +
      parsed.scores.flow
    ) / 4;
  }

  return {
    ...parsed,
    issues: allIssues,
  };
}

/**
 * REWRITE stage: Fix identified issues
 */
async function rewriteArticle(
  article: Article,
  issues: ReviewIssue[]
): Promise<Article> {
  if (issues.length === 0) {
    return article;
  }

  const prompt = buildRewriteUserPrompt(article, issues);
  const result = await generate(prompt, { system: REWRITE_SYSTEM_PROMPT });

  if (!result.success) {
    aiLogger.error({ error: result.error }, 'Rewrite stage failed');
    return article; // Return original if rewrite fails
  }

  // Parse response
  try {
    const jsonMatch = result.data.response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return article;

    const parsed = JSON.parse(jsonMatch[0]) as unknown;

    if (
      typeof parsed === 'object' &&
      parsed !== null &&
      'title' in parsed &&
      'content' in parsed &&
      'excerpt' in parsed
    ) {
      return parsed as Article;
    }
  } catch {
    aiLogger.warn('Failed to parse rewrite response');
  }

  return article;
}

/**
 * POLISH stage: Final grammar/spelling pass
 */
async function polishArticle(article: Article): Promise<Article> {
  const prompt = buildPolishUserPrompt(article);
  const result = await generate(prompt, { system: POLISH_SYSTEM_PROMPT });

  if (!result.success) {
    aiLogger.error({ error: result.error }, 'Polish stage failed');
    return article; // Return original if polish fails
  }

  // Parse response
  try {
    const jsonMatch = result.data.response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return article;

    const parsed = JSON.parse(jsonMatch[0]) as unknown;

    if (
      typeof parsed === 'object' &&
      parsed !== null &&
      'title' in parsed &&
      'content' in parsed &&
      'excerpt' in parsed
    ) {
      return parsed as Article;
    }
  } catch {
    aiLogger.warn('Failed to parse polish response');
  }

  return article;
}

// =============================================================================
// Main Pipeline
// =============================================================================

/**
 * Run the full article pipeline: REVIEW → REWRITE (loop) → POLISH
 */
export async function runArticlePipeline(article: Article): Promise<PipelineResult> {
  const reviewHistory: ReviewResult[] = [];
  let currentArticle = article;
  let rewriteCount = 0;

  aiLogger.info('Starting article pipeline');

  // Stage 1: Initial REVIEW
  aiLogger.info('Pipeline stage: REVIEW');
  let review = await reviewArticle(currentArticle);
  reviewHistory.push(review);

  // Stage 2: REWRITE loop (max 2 attempts)
  while (
    !review.pass &&
    review.issues.length > 0 &&
    rewriteCount < PIPELINE_CONFIG.maxRewriteAttempts
  ) {
    aiLogger.info(
      { attempt: rewriteCount + 1, issueCount: review.issues.length },
      'Pipeline stage: REWRITE'
    );

    currentArticle = await rewriteArticle(currentArticle, review.issues);
    rewriteCount++;

    // Re-review after rewrite
    aiLogger.info('Pipeline stage: REVIEW (post-rewrite)');
    review = await reviewArticle(currentArticle);
    reviewHistory.push(review);
  }

  // Stage 3: POLISH (always run, even if review didn't pass)
  aiLogger.info('Pipeline stage: POLISH');
  currentArticle = await polishArticle(currentArticle);

  const finalScore = review.overall;
  const passed = review.pass;

  aiLogger.info(
    {
      finalScore,
      passed,
      rewriteCount,
      reviewCount: reviewHistory.length,
    },
    'Article pipeline complete'
  );

  return {
    article: currentArticle,
    reviewHistory,
    rewriteCount,
    finalScore,
    passed,
  };
}
```

**Step 2: Run type-check**

```bash
pnpm type-check
```

**Step 3: Commit**

```bash
git add apps/admin/lib/ai/pipeline.ts
git commit -m "feat(ai): add article pipeline with review, rewrite, and polish stages"
```

---

## Task 6: Update Queue Worker to Use Pipeline

**Files:**
- Modify: `apps/admin/lib/ai/queue-worker.ts`

**Step 1: Import pipeline**

Add to imports at top of `queue-worker.ts`:

```typescript
import { runArticlePipeline } from './pipeline';
```

**Step 2: Update processJob function**

Find the section where `post_generation` jobs are handled (around line 128-145) and replace with:

```typescript
    // For post_generation jobs, parse the response and run through pipeline
    if (job.requestType === 'post_generation') {
      const parsedResult = parsePostGenerationResult(result.data.response);
      if (parsedResult) {
        aiLogger.info({ jobId: job.id }, 'Running article through quality pipeline');

        // Run through REVIEW → REWRITE → POLISH pipeline
        const pipelineResult = await runArticlePipeline(parsedResult);

        aiLogger.info(
          {
            jobId: job.id,
            finalScore: pipelineResult.finalScore,
            passed: pipelineResult.passed,
            rewriteCount: pipelineResult.rewriteCount,
          },
          'Article pipeline completed'
        );

        resultData.title = pipelineResult.article.title;
        resultData.content = pipelineResult.article.content;
        resultData.excerpt = pipelineResult.article.excerpt;
        resultData.pipelineScore = pipelineResult.finalScore;
        resultData.pipelinePassed = pipelineResult.passed;
        resultData.pipelineRewriteCount = pipelineResult.rewriteCount;
      } else {
        aiLogger.warn(
          { jobId: job.id },
          'Failed to parse post generation result, storing raw response'
        );
      }
    }
```

**Step 3: Run tests**

```bash
pnpm --filter=@repo/admin test
```

**Step 4: Run type-check**

```bash
pnpm type-check
```

**Step 5: Commit**

```bash
git add apps/admin/lib/ai/queue-worker.ts
git commit -m "feat(ai): integrate article pipeline into queue worker"
```

---

## Task 7: Update AI Module Exports

**Files:**
- Modify: `apps/admin/lib/ai/index.ts`

**Step 1: Add pipeline exports**

Add to `apps/admin/lib/ai/index.ts`:

```typescript
// Pipeline
export { runArticlePipeline } from './pipeline';
export type { ReviewResult, ReviewScores, ReviewIssue } from './prompts';
export { PIPELINE_CONFIG } from './prompts';
```

**Step 2: Run type-check**

```bash
pnpm type-check
```

**Step 3: Commit**

```bash
git add apps/admin/lib/ai/index.ts
git commit -m "feat(ai): export pipeline from AI module"
```

---

## Task 8: Add Pipeline Tests

**Files:**
- Create: `apps/admin/lib/ai/__tests__/pipeline.test.ts`

**Step 1: Create pipeline tests**

Create `apps/admin/lib/ai/__tests__/pipeline.test.ts`:

```typescript
import { describe, expect, it } from 'vitest';

import {
  findAllBanned,
  findBannedPhrases,
  findBannedWords,
} from '../prompts/banned-words';
import { parseReviewResponse } from '../prompts/review';
import { PIPELINE_CONFIG } from '../prompts/types';

describe('banned-words', () => {
  describe('findBannedWords', () => {
    it('finds Croatian banned words', () => {
      const text = 'Ovo je revolucionarno rješenje za transformativni pristup.';
      const found = findBannedWords(text);

      expect(found).toContain('revolucionarno');
      expect(found).toContain('transformativni');
    });

    it('finds English buzzwords', () => {
      const text = 'This is a game-changing, cutting-edge solution.';
      const found = findBannedWords(text);

      expect(found).toContain('game-changing');
      expect(found).toContain('cutting-edge');
    });

    it('returns empty array when no banned words', () => {
      const text = 'Općina Veliki Bukovec organizira radnu akciju čišćenja.';
      const found = findBannedWords(text);

      expect(found).toHaveLength(0);
    });

    it('is case insensitive', () => {
      const text = 'REVOLUCIONARNO rješenje';
      const found = findBannedWords(text);

      expect(found).toContain('revolucionarno');
    });
  });

  describe('findBannedPhrases', () => {
    it('finds banned phrases', () => {
      const text = 'U današnjem svijetu, važno je napomenuti da...';
      const found = findBannedPhrases(text);

      expect(found).toContain('u današnjem svijetu');
      expect(found).toContain('važno je napomenuti');
    });

    it('returns empty array when no banned phrases', () => {
      const text = 'Općina objavljuje natječaj za stipendije.';
      const found = findBannedPhrases(text);

      expect(found).toHaveLength(0);
    });
  });

  describe('findAllBanned', () => {
    it('returns both words and phrases', () => {
      const text = 'U današnjem svijetu, ovo revolucionarno rješenje...';
      const result = findAllBanned(text);

      expect(result.words).toContain('revolucionarno');
      expect(result.phrases).toContain('u današnjem svijetu');
    });
  });
});

describe('review parser', () => {
  it('parses valid review response', () => {
    const response = `
    {
      "scores": {
        "clarity": 8,
        "localRelevance": 7,
        "slopScore": 9,
        "flow": 8
      },
      "overall": 8,
      "pass": true,
      "issues": []
    }
    `;

    const result = parseReviewResponse(response);

    expect(result).not.toBeNull();
    expect(result?.scores.clarity).toBe(8);
    expect(result?.pass).toBe(true);
    expect(result?.issues).toHaveLength(0);
  });

  it('parses review with issues', () => {
    const response = `
    {
      "scores": {
        "clarity": 6,
        "localRelevance": 5,
        "slopScore": 4,
        "flow": 6
      },
      "overall": 5.25,
      "pass": false,
      "issues": [
        {
          "type": "slop_word",
          "location": "odlomak 1",
          "text": "revolucionarno",
          "fix": "Zamijeni s konkretnim opisom"
        }
      ]
    }
    `;

    const result = parseReviewResponse(response);

    expect(result).not.toBeNull();
    expect(result?.pass).toBe(false);
    expect(result?.issues).toHaveLength(1);
    expect(result?.issues[0].type).toBe('slop_word');
  });

  it('extracts JSON from text with extra content', () => {
    const response = `
    Evo moje analize:

    {
      "scores": { "clarity": 8, "localRelevance": 7, "slopScore": 9, "flow": 8 },
      "overall": 8,
      "pass": true,
      "issues": []
    }

    Nadam se da je ovo korisno!
    `;

    const result = parseReviewResponse(response);

    expect(result).not.toBeNull();
    expect(result?.pass).toBe(true);
  });

  it('returns null for invalid JSON', () => {
    const response = 'This is not JSON at all';

    const result = parseReviewResponse(response);

    expect(result).toBeNull();
  });

  it('returns null for missing required fields', () => {
    const response = '{ "scores": { "clarity": 8 } }';

    const result = parseReviewResponse(response);

    expect(result).toBeNull();
  });
});

describe('pipeline config', () => {
  it('has correct default values', () => {
    expect(PIPELINE_CONFIG.qualityThreshold).toBe(7.0);
    expect(PIPELINE_CONFIG.maxRewriteAttempts).toBe(2);
    expect(PIPELINE_CONFIG.maxSentenceWords).toBe(30);
  });
});
```

**Step 2: Run tests**

```bash
pnpm --filter=@repo/admin test
```

**Step 3: Commit**

```bash
git add apps/admin/lib/ai/__tests__/pipeline.test.ts
git commit -m "test(ai): add tests for banned words and review parser"
```

---

## Task 9: Final Verification

**Step 1: Run all checks**

```bash
cd /home/wandeon/WebVB
pnpm type-check
pnpm lint --filter=@repo/admin
pnpm --filter=@repo/admin test
```

**Step 2: Verify file structure**

```bash
ls -la apps/admin/lib/ai/prompts/
ls -la apps/admin/lib/ai/pipeline.ts
```

Expected:
- `apps/admin/lib/ai/prompts/banned-words.ts`
- `apps/admin/lib/ai/prompts/types.ts`
- `apps/admin/lib/ai/prompts/review.ts`
- `apps/admin/lib/ai/prompts/rewrite.ts`
- `apps/admin/lib/ai/prompts/polish.ts`
- `apps/admin/lib/ai/prompts/index.ts`
- `apps/admin/lib/ai/pipeline.ts`

**Step 3: Check for TODO/FIXME**

```bash
grep -r "TODO\|FIXME" apps/admin/lib/ai/prompts/ apps/admin/lib/ai/pipeline.ts
```

Expected: No output

---

## Summary

| Task | Description |
|------|-------------|
| 1 | Create banned words list and review types |
| 2 | Create review stage prompt |
| 3 | Create rewrite stage prompt |
| 4 | Create polish stage prompt |
| 5 | Create pipeline processor |
| 6 | Update queue worker to use pipeline |
| 7 | Update AI module exports |
| 8 | Add pipeline tests |
| 9 | Final verification |

## Files Created/Modified

**Created:**
- `apps/admin/lib/ai/prompts/types.ts` - Review types and config
- `apps/admin/lib/ai/prompts/banned-words.ts` - Croatian banned words
- `apps/admin/lib/ai/prompts/review.ts` - Review stage prompt
- `apps/admin/lib/ai/prompts/rewrite.ts` - Rewrite stage prompt
- `apps/admin/lib/ai/prompts/polish.ts` - Polish stage prompt
- `apps/admin/lib/ai/prompts/index.ts` - Prompts module exports
- `apps/admin/lib/ai/pipeline.ts` - Pipeline orchestrator
- `apps/admin/lib/ai/__tests__/pipeline.test.ts` - Pipeline tests

**Modified:**
- `apps/admin/lib/ai/queue-worker.ts` - Integrate pipeline
- `apps/admin/lib/ai/index.ts` - Export pipeline

## LLM Calls Per Article

| Stage | Calls | Notes |
|-------|-------|-------|
| Write | 1 | Already exists |
| Review | 1-3 | Initial + after each rewrite |
| Rewrite | 0-2 | Only if review fails |
| Polish | 1 | Always runs |
| **Total** | **3-7** | Depends on quality |
