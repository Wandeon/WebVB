# Sprint 1.3: Posts List + CRUD Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a complete posts management system with list view, filtering, pagination, and full CRUD operations.

**Architecture:** Server-side API routes with Prisma ORM for database operations. React components for the UI with client-side form validation using Zod. Server Actions for mutations with optimistic updates where appropriate.

**Tech Stack:** Next.js 16 App Router, Prisma, Zod, React Hook Form, TanStack Table, shadcn/ui components

---

## Context

**Post Model (from schema.prisma):**
```prisma
model Post {
  id             String    @id @default(uuid())
  title          String
  slug           String    @unique
  content        String    // Rich text (TipTap HTML) - placeholder textarea for now
  excerpt        String?
  featuredImage  String?
  images         Json?
  category       String    @default("aktualnosti")
  isFeatured     Boolean   @default(false)
  facebookPostId String?
  authorId       String?
  publishedAt    DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  author         User?     @relation(...)
}
```

**Categories (Croatian):**
- `aktualnosti` - Općinske aktualnosti
- `gospodarstvo` - Gospodarstvo
- `sport` - Sport
- `komunalno` - Komunalne teme
- `kultura` - Kultura
- `obrazovanje` - Obrazovanje
- `ostalo` - Ostalo

**Status (derived from publishedAt):**
- Draft: `publishedAt === null`
- Published: `publishedAt !== null`

---

## Task 1: Add Required UI Primitives

**Files:**
- Create: `packages/ui/src/primitives/table.tsx`
- Create: `packages/ui/src/primitives/dialog.tsx`
- Create: `packages/ui/src/primitives/select.tsx`
- Create: `packages/ui/src/primitives/badge.tsx`
- Create: `packages/ui/src/primitives/textarea.tsx`
- Create: `packages/ui/src/primitives/toast.tsx`
- Create: `packages/ui/src/primitives/toaster.tsx`
- Create: `packages/ui/src/primitives/use-toast.ts`
- Modify: `packages/ui/src/primitives/index.ts`
- Modify: `packages/ui/package.json`

**Step 1: Install required dependencies**

```bash
cd /mnt/c/VelikiBukovec_web/packages/ui && pnpm add @radix-ui/react-dialog @radix-ui/react-select @tanstack/react-table
```

**Step 2: Create Table component**

Create `packages/ui/src/primitives/table.tsx`:
```tsx
import { forwardRef, type HTMLAttributes, type TdHTMLAttributes, type ThHTMLAttributes } from 'react';

import { cn } from '../lib/utils';

const Table = forwardRef<HTMLTableElement, HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className="relative w-full overflow-auto">
      <table
        ref={ref}
        className={cn('w-full caption-bottom text-sm', className)}
        {...props}
      />
    </div>
  )
);
Table.displayName = 'Table';

const TableHeader = forwardRef<
  HTMLTableSectionElement,
  HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />
));
TableHeader.displayName = 'TableHeader';

const TableBody = forwardRef<
  HTMLTableSectionElement,
  HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn('[&_tr:last-child]:border-0', className)}
    {...props}
  />
));
TableBody.displayName = 'TableBody';

const TableFooter = forwardRef<
  HTMLTableSectionElement,
  HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn('border-t bg-neutral-100/50 font-medium [&>tr]:last:border-b-0', className)}
    {...props}
  />
));
TableFooter.displayName = 'TableFooter';

const TableRow = forwardRef<
  HTMLTableRowElement,
  HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      'border-b transition-colors hover:bg-neutral-100/50 data-[state=selected]:bg-neutral-100',
      className
    )}
    {...props}
  />
));
TableRow.displayName = 'TableRow';

const TableHead = forwardRef<
  HTMLTableCellElement,
  ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      'h-12 px-4 text-left align-middle font-medium text-neutral-500 [&:has([role=checkbox])]:pr-0',
      className
    )}
    {...props}
  />
));
TableHead.displayName = 'TableHead';

const TableCell = forwardRef<
  HTMLTableCellElement,
  TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}
    {...props}
  />
));
TableCell.displayName = 'TableCell';

const TableCaption = forwardRef<
  HTMLTableCaptionElement,
  HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn('mt-4 text-sm text-neutral-500', className)}
    {...props}
  />
));
TableCaption.displayName = 'TableCaption';

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};
```

**Step 3: Create Dialog component**

Create `packages/ui/src/primitives/dialog.tsx`:
```tsx
'use client';

import * as DialogPrimitive from '@radix-ui/react-dialog';
import { X } from 'lucide-react';
import {
  forwardRef,
  type ComponentPropsWithoutRef,
  type ElementRef,
  type HTMLAttributes,
} from 'react';

import { cn } from '../lib/utils';

const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;

const DialogOverlay = forwardRef<
  ElementRef<typeof DialogPrimitive.Overlay>,
  ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = forwardRef<
  ElementRef<typeof DialogPrimitive.Content>,
  ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-white p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-white transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-neutral-100 data-[state=open]:text-neutral-500">
        <X className="h-4 w-4" aria-hidden="true" />
        <span className="sr-only">Zatvori</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col space-y-1.5 text-center sm:text-left', className)}
    {...props}
  />
);
DialogHeader.displayName = 'DialogHeader';

const DialogFooter = ({ className, ...props }: HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
);
DialogFooter.displayName = 'DialogFooter';

const DialogTitle = forwardRef<
  ElementRef<typeof DialogPrimitive.Title>,
  ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold leading-none tracking-tight', className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = forwardRef<
  ElementRef<typeof DialogPrimitive.Description>,
  ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-neutral-500', className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
```

**Step 4: Create Select component**

Create `packages/ui/src/primitives/select.tsx`:
```tsx
'use client';

import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';
import { forwardRef, type ComponentPropsWithoutRef, type ElementRef } from 'react';

import { cn } from '../lib/utils';

const Select = SelectPrimitive.Root;
const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value;

const SelectTrigger = forwardRef<
  ElementRef<typeof SelectPrimitive.Trigger>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-neutral-300 bg-white px-3 py-2 text-sm ring-offset-white placeholder:text-neutral-500 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" aria-hidden="true" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = forwardRef<
  ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" aria-hidden="true" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = forwardRef<
  ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" aria-hidden="true" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = forwardRef<
  ElementRef<typeof SelectPrimitive.Content>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-white text-neutral-900 shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = forwardRef<
  ElementRef<typeof SelectPrimitive.Label>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = forwardRef<
  ElementRef<typeof SelectPrimitive.Item>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-neutral-100 focus:text-neutral-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" aria-hidden="true" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = forwardRef<
  ElementRef<typeof SelectPrimitive.Separator>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-neutral-100', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
```

**Step 5: Create Badge component**

Create `packages/ui/src/primitives/badge.tsx`:
```tsx
import { cva, type VariantProps } from 'class-variance-authority';
import { type HTMLAttributes } from 'react';

import { cn } from '../lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2',
  {
    variants: {
      variant: {
        default: 'border-transparent bg-primary-600 text-white',
        secondary: 'border-transparent bg-neutral-100 text-neutral-900',
        success: 'border-transparent bg-green-100 text-green-800',
        warning: 'border-transparent bg-yellow-100 text-yellow-800',
        danger: 'border-transparent bg-red-100 text-red-800',
        outline: 'text-neutral-900',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface BadgeProps
  extends HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };
```

**Step 6: Create Textarea component**

Create `packages/ui/src/primitives/textarea.tsx`:
```tsx
import { forwardRef, type TextareaHTMLAttributes } from 'react';

import { cn } from '../lib/utils';

export interface TextareaProps extends TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[80px] w-full rounded-md border border-neutral-300 bg-white px-3 py-2 text-sm ring-offset-white placeholder:text-neutral-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = 'Textarea';

export { Textarea };
```

**Step 7: Create Toast components**

Create `packages/ui/src/primitives/use-toast.ts`:
```tsx
'use client';

import { useCallback, useEffect, useState } from 'react';

const TOAST_LIMIT = 3;
const TOAST_REMOVE_DELAY = 5000;

type ToastType = 'default' | 'success' | 'error' | 'warning';

export type Toast = {
  id: string;
  title?: string;
  description?: string;
  type?: ToastType;
};

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ToastState = {
  toasts: Toast[];
};

const listeners: Array<(state: ToastState) => void> = [];
let memoryState: ToastState = { toasts: [] };

function dispatch(action: { type: 'ADD_TOAST'; toast: Toast } | { type: 'DISMISS_TOAST'; id: string } | { type: 'REMOVE_TOAST'; id: string }) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

function reducer(state: ToastState, action: { type: 'ADD_TOAST'; toast: Toast } | { type: 'DISMISS_TOAST'; id: string } | { type: 'REMOVE_TOAST'; id: string }): ToastState {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };
    case 'DISMISS_TOAST':
    case 'REMOVE_TOAST':
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.id),
      };
    default:
      return state;
  }
}

function toast({ title, description, type = 'default' }: Omit<Toast, 'id'>) {
  const id = genId();

  dispatch({
    type: 'ADD_TOAST',
    toast: { id, title, description, type },
  });

  setTimeout(() => {
    dispatch({ type: 'REMOVE_TOAST', id });
  }, TOAST_REMOVE_DELAY);

  return id;
}

function useToast() {
  const [state, setState] = useState<ToastState>(memoryState);

  useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, []);

  const dismiss = useCallback((id: string) => {
    dispatch({ type: 'DISMISS_TOAST', id });
  }, []);

  return {
    ...state,
    toast,
    dismiss,
  };
}

export { useToast, toast };
```

Create `packages/ui/src/primitives/toast.tsx`:
```tsx
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';
import { forwardRef, type HTMLAttributes } from 'react';

import { cn } from '../lib/utils';

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-4 pr-8 shadow-lg transition-all',
  {
    variants: {
      variant: {
        default: 'border-neutral-200 bg-white text-neutral-900',
        success: 'border-green-200 bg-green-50 text-green-900',
        error: 'border-red-200 bg-red-50 text-red-900',
        warning: 'border-yellow-200 bg-yellow-50 text-yellow-900',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface ToastProps
  extends HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof toastVariants> {
  onClose?: () => void;
}

const Toast = forwardRef<HTMLDivElement, ToastProps>(
  ({ className, variant, children, onClose, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(toastVariants({ variant }), className)}
        {...props}
      >
        <div className="flex-1">{children}</div>
        {onClose && (
          <button
            onClick={onClose}
            className="absolute right-2 top-2 rounded-md p-1 text-neutral-500 opacity-0 transition-opacity hover:text-neutral-900 focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100"
          >
            <X className="h-4 w-4" aria-hidden="true" />
            <span className="sr-only">Zatvori</span>
          </button>
        )}
      </div>
    );
  }
);
Toast.displayName = 'Toast';

const ToastTitle = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn('text-sm font-semibold', className)} {...props} />
  )
);
ToastTitle.displayName = 'ToastTitle';

const ToastDescription = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn('text-sm opacity-90', className)} {...props} />
  )
);
ToastDescription.displayName = 'ToastDescription';

export { Toast, ToastTitle, ToastDescription, toastVariants };
```

Create `packages/ui/src/primitives/toaster.tsx`:
```tsx
'use client';

import { Toast, ToastDescription, ToastTitle } from './toast';
import { useToast } from './use-toast';

const variantMap = {
  default: 'default',
  success: 'success',
  error: 'error',
  warning: 'warning',
} as const;

export function Toaster() {
  const { toasts, dismiss } = useToast();

  return (
    <div className="fixed bottom-0 right-0 z-[100] flex max-h-screen w-full flex-col-reverse gap-2 p-4 sm:max-w-[420px]">
      {toasts.map((t) => (
        <Toast
          key={t.id}
          variant={variantMap[t.type ?? 'default']}
          onClose={() => dismiss(t.id)}
        >
          <div className="grid gap-1">
            {t.title && <ToastTitle>{t.title}</ToastTitle>}
            {t.description && <ToastDescription>{t.description}</ToastDescription>}
          </div>
        </Toast>
      ))}
    </div>
  );
}
```

**Step 8: Update exports**

Modify `packages/ui/src/primitives/index.ts` to add:
```tsx
export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
} from './table';
export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
} from './dialog';
export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
} from './select';
export { Badge, badgeVariants, type BadgeProps } from './badge';
export { Textarea, type TextareaProps } from './textarea';
export { Toast, ToastTitle, ToastDescription, toastVariants, type ToastProps } from './toast';
export { Toaster } from './toaster';
export { useToast, toast } from './use-toast';
```

**Step 9: Verify and commit**

```bash
cd /mnt/c/VelikiBukovec_web && pnpm lint && pnpm type-check
git add packages/ui/
git commit -m "feat(ui): add table, dialog, select, badge, textarea, toast primitives"
```

---

## Task 2: Create Zod Schemas and Types

**Files:**
- Create: `apps/admin/lib/validations/post.ts`
- Create: `packages/shared/src/constants/categories.ts`
- Modify: `packages/shared/src/index.ts`

**Step 1: Create category constants**

Create `packages/shared/src/constants/categories.ts`:
```tsx
export const POST_CATEGORIES = {
  aktualnosti: 'Općinske aktualnosti',
  gospodarstvo: 'Gospodarstvo',
  sport: 'Sport',
  komunalno: 'Komunalne teme',
  kultura: 'Kultura',
  obrazovanje: 'Obrazovanje',
  ostalo: 'Ostalo',
} as const;

export type PostCategory = keyof typeof POST_CATEGORIES;

export const POST_CATEGORY_OPTIONS = Object.entries(POST_CATEGORIES).map(
  ([value, label]) => ({ value, label })
);
```

**Step 2: Export from shared package**

Add to `packages/shared/src/index.ts`:
```tsx
export {
  POST_CATEGORIES,
  POST_CATEGORY_OPTIONS,
  type PostCategory,
} from './constants/categories';
```

**Step 3: Create Zod validation schemas**

Create `apps/admin/lib/validations/post.ts`:
```tsx
import { z } from 'zod';

export const postSchema = z.object({
  title: z
    .string()
    .min(3, 'Naslov mora imati najmanje 3 znaka')
    .max(200, 'Naslov može imati najviše 200 znakova'),
  content: z.string().min(1, 'Sadržaj je obavezan'),
  excerpt: z.string().max(500, 'Sažetak može imati najviše 500 znakova').optional(),
  category: z.enum([
    'aktualnosti',
    'gospodarstvo',
    'sport',
    'komunalno',
    'kultura',
    'obrazovanje',
    'ostalo',
  ]),
  isFeatured: z.boolean().default(false),
  publishedAt: z.date().nullable().optional(),
});

export const createPostSchema = postSchema;

export const updatePostSchema = postSchema.partial().extend({
  id: z.string().uuid(),
});

export type CreatePostInput = z.infer<typeof createPostSchema>;
export type UpdatePostInput = z.infer<typeof updatePostSchema>;

// For API query params
export const postQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().max(100).default(10),
  search: z.string().optional(),
  category: z.string().optional(),
  status: z.enum(['all', 'draft', 'published']).default('all'),
  sortBy: z.enum(['createdAt', 'updatedAt', 'title', 'publishedAt']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
});

export type PostQueryInput = z.infer<typeof postQuerySchema>;
```

**Step 4: Commit**

```bash
git add packages/shared/src/constants/categories.ts packages/shared/src/index.ts apps/admin/lib/validations/
git commit -m "feat: add post validation schemas and category constants"
```

---

## Task 3: Create Posts API Routes

**Files:**
- Create: `apps/admin/app/api/posts/route.ts`
- Create: `apps/admin/app/api/posts/[id]/route.ts`
- Create: `apps/admin/lib/utils/slug.ts`

**Step 1: Create slug utility**

Create `apps/admin/lib/utils/slug.ts`:
```tsx
export function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
    .replace(/[čć]/g, 'c')
    .replace(/[đ]/g, 'd')
    .replace(/[š]/g, 's')
    .replace(/[ž]/g, 'z')
    .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Remove duplicate hyphens
    .replace(/^-|-$/g, ''); // Trim hyphens
}

export function generateUniqueSlug(title: string, existingSlugs: string[]): string {
  const baseSlug = generateSlug(title);

  if (!existingSlugs.includes(baseSlug)) {
    return baseSlug;
  }

  let counter = 1;
  let slug = `${baseSlug}-${counter}`;

  while (existingSlugs.includes(slug)) {
    counter++;
    slug = `${baseSlug}-${counter}`;
  }

  return slug;
}
```

**Step 2: Create main posts API route**

Create `apps/admin/app/api/posts/route.ts`:
```tsx
import { prisma } from '@repo/database';
import { type Prisma } from '@repo/database/client';
import { NextResponse } from 'next/server';

import { createPostSchema, postQuerySchema } from '@/lib/validations/post';
import { generateSlug } from '@/lib/utils/slug';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const params = Object.fromEntries(searchParams.entries());

    const query = postQuerySchema.parse(params);
    const { page, limit, search, category, status, sortBy, sortOrder } = query;

    const where: Prisma.PostWhereInput = {};

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { content: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (category) {
      where.category = category;
    }

    if (status === 'draft') {
      where.publishedAt = null;
    } else if (status === 'published') {
      where.publishedAt = { not: null };
    }

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        orderBy: { [sortBy]: sortOrder },
        skip: (page - 1) * limit,
        take: limit,
        include: {
          author: {
            select: { id: true, name: true, email: true },
          },
        },
      }),
      prisma.post.count({ where }),
    ]);

    return NextResponse.json({
      posts,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error('GET /api/posts error:', error);
    return NextResponse.json(
      { error: 'Greška pri dohvaćanju objava' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const data = createPostSchema.parse(body);

    // Generate unique slug
    const existingSlugs = await prisma.post.findMany({
      select: { slug: true },
    });
    const slug = generateSlug(data.title);
    let uniqueSlug = slug;
    let counter = 1;

    while (existingSlugs.some((p) => p.slug === uniqueSlug)) {
      uniqueSlug = `${slug}-${counter}`;
      counter++;
    }

    const post = await prisma.post.create({
      data: {
        ...data,
        slug: uniqueSlug,
        publishedAt: data.publishedAt ?? null,
      },
    });

    return NextResponse.json(post, { status: 201 });
  } catch (error) {
    console.error('POST /api/posts error:', error);

    if (error instanceof Error && error.name === 'ZodError') {
      return NextResponse.json(
        { error: 'Nevaljani podaci', details: error },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Greška pri stvaranju objave' },
      { status: 500 }
    );
  }
}
```

**Step 3: Create single post API route**

Create `apps/admin/app/api/posts/[id]/route.ts`:
```tsx
import { prisma } from '@repo/database';
import { NextResponse } from 'next/server';

import { updatePostSchema } from '@/lib/validations/post';
import { generateSlug } from '@/lib/utils/slug';

interface RouteParams {
  params: Promise<{ id: string }>;
}

export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { id } = await params;

    const post = await prisma.post.findUnique({
      where: { id },
      include: {
        author: {
          select: { id: true, name: true, email: true },
        },
      },
    });

    if (!post) {
      return NextResponse.json(
        { error: 'Objava nije pronađena' },
        { status: 404 }
      );
    }

    return NextResponse.json(post);
  } catch (error) {
    console.error('GET /api/posts/[id] error:', error);
    return NextResponse.json(
      { error: 'Greška pri dohvaćanju objave' },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request, { params }: RouteParams) {
  try {
    const { id } = await params;
    const body = await request.json();
    const data = updatePostSchema.parse({ ...body, id });

    // Check if post exists
    const existing = await prisma.post.findUnique({ where: { id } });
    if (!existing) {
      return NextResponse.json(
        { error: 'Objava nije pronađena' },
        { status: 404 }
      );
    }

    // If title changed, regenerate slug
    let slug = existing.slug;
    if (data.title && data.title !== existing.title) {
      const existingSlugs = await prisma.post.findMany({
        where: { id: { not: id } },
        select: { slug: true },
      });
      const baseSlug = generateSlug(data.title);
      slug = baseSlug;
      let counter = 1;

      while (existingSlugs.some((p) => p.slug === slug)) {
        slug = `${baseSlug}-${counter}`;
        counter++;
      }
    }

    const { id: _id, ...updateData } = data;

    const post = await prisma.post.update({
      where: { id },
      data: {
        ...updateData,
        slug,
      },
    });

    return NextResponse.json(post);
  } catch (error) {
    console.error('PUT /api/posts/[id] error:', error);

    if (error instanceof Error && error.name === 'ZodError') {
      return NextResponse.json(
        { error: 'Nevaljani podaci', details: error },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Greška pri ažuriranju objave' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: RouteParams) {
  try {
    const { id } = await params;

    const existing = await prisma.post.findUnique({ where: { id } });
    if (!existing) {
      return NextResponse.json(
        { error: 'Objava nije pronađena' },
        { status: 404 }
      );
    }

    await prisma.post.delete({ where: { id } });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('DELETE /api/posts/[id] error:', error);
    return NextResponse.json(
      { error: 'Greška pri brisanju objave' },
      { status: 500 }
    );
  }
}
```

**Step 4: Commit**

```bash
git add apps/admin/app/api/posts/ apps/admin/lib/utils/slug.ts
git commit -m "feat(api): add posts CRUD API routes with validation"
```

---

## Task 4: Create Data Table Components

**Files:**
- Create: `apps/admin/components/posts/data-table.tsx`
- Create: `apps/admin/components/posts/columns.tsx`
- Create: `apps/admin/components/posts/data-table-pagination.tsx`
- Create: `apps/admin/components/posts/data-table-toolbar.tsx`
- Modify: `apps/admin/package.json` (add @tanstack/react-table)

**Step 1: Install dependencies**

```bash
cd /mnt/c/VelikiBukovec_web/apps/admin && pnpm add @tanstack/react-table
```

**Step 2: Create columns definition**

Create `apps/admin/components/posts/columns.tsx`:
```tsx
'use client';

import { type ColumnDef } from '@tanstack/react-table';
import { MoreHorizontal, Pencil, Trash2 } from 'lucide-react';
import Link from 'next/link';

import { POST_CATEGORIES } from '@repo/shared';
import {
  Badge,
  Button,
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@repo/ui';

export type Post = {
  id: string;
  title: string;
  slug: string;
  category: string;
  publishedAt: string | null;
  createdAt: string;
  author: { name: string } | null;
};

interface ColumnsProps {
  onDelete: (id: string, title: string) => void;
}

export function getColumns({ onDelete }: ColumnsProps): ColumnDef<Post>[] {
  return [
    {
      accessorKey: 'title',
      header: 'Naslov',
      cell: ({ row }) => (
        <div className="max-w-[300px]">
          <Link
            href={`/posts/${row.original.id}`}
            className="font-medium text-neutral-900 hover:text-primary-600 hover:underline"
          >
            {row.getValue('title')}
          </Link>
        </div>
      ),
    },
    {
      accessorKey: 'category',
      header: 'Kategorija',
      cell: ({ row }) => {
        const category = row.getValue('category') as string;
        const label = POST_CATEGORIES[category as keyof typeof POST_CATEGORIES] ?? category;
        return <Badge variant="secondary">{label}</Badge>;
      },
    },
    {
      accessorKey: 'publishedAt',
      header: 'Status',
      cell: ({ row }) => {
        const publishedAt = row.getValue('publishedAt');
        return publishedAt ? (
          <Badge variant="success">Objavljeno</Badge>
        ) : (
          <Badge variant="warning">Skica</Badge>
        );
      },
    },
    {
      accessorKey: 'author',
      header: 'Autor',
      cell: ({ row }) => {
        const author = row.original.author;
        return <span className="text-neutral-600">{author?.name ?? 'Nepoznat'}</span>;
      },
    },
    {
      accessorKey: 'createdAt',
      header: 'Stvoreno',
      cell: ({ row }) => {
        const date = new Date(row.getValue('createdAt'));
        return (
          <span className="text-neutral-600">
            {date.toLocaleDateString('hr-HR')}
          </span>
        );
      },
    },
    {
      id: 'actions',
      cell: ({ row }) => {
        const post = row.original;
        return (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="icon" className="h-8 w-8">
                <span className="sr-only">Otvori izbornik</span>
                <MoreHorizontal className="h-4 w-4" aria-hidden="true" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem asChild>
                <Link href={`/posts/${post.id}`}>
                  <Pencil className="mr-2 h-4 w-4" aria-hidden="true" />
                  Uredi
                </Link>
              </DropdownMenuItem>
              <DropdownMenuItem
                className="text-red-600 focus:text-red-600"
                onClick={() => onDelete(post.id, post.title)}
              >
                <Trash2 className="mr-2 h-4 w-4" aria-hidden="true" />
                Obriši
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        );
      },
    },
  ];
}
```

**Step 3: Create pagination component**

Create `apps/admin/components/posts/data-table-pagination.tsx`:
```tsx
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react';

import { Button } from '@repo/ui';

interface DataTablePaginationProps {
  page: number;
  totalPages: number;
  onPageChange: (page: number) => void;
}

export function DataTablePagination({
  page,
  totalPages,
  onPageChange,
}: DataTablePaginationProps) {
  return (
    <div className="flex items-center justify-between px-2">
      <div className="text-sm text-neutral-600">
        Stranica {page} od {totalPages}
      </div>
      <div className="flex items-center space-x-2">
        <Button
          variant="outline"
          size="icon"
          className="h-8 w-8"
          onClick={() => onPageChange(1)}
          disabled={page <= 1}
        >
          <span className="sr-only">Prva stranica</span>
          <ChevronsLeft className="h-4 w-4" aria-hidden="true" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          className="h-8 w-8"
          onClick={() => onPageChange(page - 1)}
          disabled={page <= 1}
        >
          <span className="sr-only">Prethodna stranica</span>
          <ChevronLeft className="h-4 w-4" aria-hidden="true" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          className="h-8 w-8"
          onClick={() => onPageChange(page + 1)}
          disabled={page >= totalPages}
        >
          <span className="sr-only">Sljedeća stranica</span>
          <ChevronRight className="h-4 w-4" aria-hidden="true" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          className="h-8 w-8"
          onClick={() => onPageChange(totalPages)}
          disabled={page >= totalPages}
        >
          <span className="sr-only">Zadnja stranica</span>
          <ChevronsRight className="h-4 w-4" aria-hidden="true" />
        </Button>
      </div>
    </div>
  );
}
```

**Step 4: Create toolbar component**

Create `apps/admin/components/posts/data-table-toolbar.tsx`:
```tsx
'use client';

import { Search, X } from 'lucide-react';
import { useCallback, useState } from 'react';

import { POST_CATEGORY_OPTIONS } from '@repo/shared';
import {
  Button,
  Input,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@repo/ui';

interface DataTableToolbarProps {
  search: string;
  category: string;
  status: string;
  onSearchChange: (search: string) => void;
  onCategoryChange: (category: string) => void;
  onStatusChange: (status: string) => void;
  onReset: () => void;
}

export function DataTableToolbar({
  search,
  category,
  status,
  onSearchChange,
  onCategoryChange,
  onStatusChange,
  onReset,
}: DataTableToolbarProps) {
  const [searchValue, setSearchValue] = useState(search);

  const handleSearchSubmit = useCallback(
    (e: React.FormEvent) => {
      e.preventDefault();
      onSearchChange(searchValue);
    },
    [searchValue, onSearchChange]
  );

  const hasFilters = search || category || status !== 'all';

  return (
    <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
      <form onSubmit={handleSearchSubmit} className="flex flex-1 items-center gap-2">
        <div className="relative flex-1 sm:max-w-xs">
          <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-neutral-400" aria-hidden="true" />
          <Input
            placeholder="Pretraži objave..."
            value={searchValue}
            onChange={(e) => setSearchValue(e.target.value)}
            className="pl-9"
          />
        </div>
        <Button type="submit" variant="outline" size="sm">
          Traži
        </Button>
      </form>

      <div className="flex flex-wrap items-center gap-2">
        <Select value={category} onValueChange={onCategoryChange}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Kategorija" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Sve kategorije</SelectItem>
            {POST_CATEGORY_OPTIONS.map((opt) => (
              <SelectItem key={opt.value} value={opt.value}>
                {opt.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>

        <Select value={status} onValueChange={onStatusChange}>
          <SelectTrigger className="w-[140px]">
            <SelectValue placeholder="Status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Svi statusi</SelectItem>
            <SelectItem value="published">Objavljeno</SelectItem>
            <SelectItem value="draft">Skica</SelectItem>
          </SelectContent>
        </Select>

        {hasFilters && (
          <Button variant="ghost" size="sm" onClick={onReset}>
            <X className="mr-2 h-4 w-4" aria-hidden="true" />
            Poništi
          </Button>
        )}
      </div>
    </div>
  );
}
```

**Step 5: Create main data table component**

Create `apps/admin/components/posts/data-table.tsx`:
```tsx
'use client';

import {
  flexRender,
  getCoreRowModel,
  useReactTable,
} from '@tanstack/react-table';

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@repo/ui';

import { type Post, getColumns } from './columns';
import { DataTablePagination } from './data-table-pagination';
import { DataTableToolbar } from './data-table-toolbar';

interface DataTableProps {
  posts: Post[];
  pagination: {
    page: number;
    totalPages: number;
    total: number;
  };
  filters: {
    search: string;
    category: string;
    status: string;
  };
  onFiltersChange: (filters: { search?: string; category?: string; status?: string }) => void;
  onPageChange: (page: number) => void;
  onDelete: (id: string, title: string) => void;
  isLoading?: boolean;
}

export function DataTable({
  posts,
  pagination,
  filters,
  onFiltersChange,
  onPageChange,
  onDelete,
  isLoading,
}: DataTableProps) {
  const columns = getColumns({ onDelete });

  const table = useReactTable({
    data: posts,
    columns,
    getCoreRowModel: getCoreRowModel(),
    manualPagination: true,
    pageCount: pagination.totalPages,
  });

  return (
    <div className="space-y-4">
      <DataTableToolbar
        search={filters.search}
        category={filters.category}
        status={filters.status}
        onSearchChange={(search) => onFiltersChange({ search })}
        onCategoryChange={(category) => onFiltersChange({ category: category === 'all' ? '' : category })}
        onStatusChange={(status) => onFiltersChange({ status })}
        onReset={() => onFiltersChange({ search: '', category: '', status: 'all' })}
      />

      <div className="rounded-md border">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(header.column.columnDef.header, header.getContext())}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  Učitavanje...
                </TableCell>
              </TableRow>
            ) : table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow key={row.id} data-state={row.getIsSelected() && 'selected'}>
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  Nema objava.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {pagination.totalPages > 1 && (
        <DataTablePagination
          page={pagination.page}
          totalPages={pagination.totalPages}
          onPageChange={onPageChange}
        />
      )}
    </div>
  );
}
```

**Step 6: Commit**

```bash
git add apps/admin/components/posts/ apps/admin/package.json pnpm-lock.yaml
git commit -m "feat(posts): add data table components with filtering and pagination"
```

---

## Task 5: Create Post Form Components

**Files:**
- Create: `apps/admin/components/posts/post-form.tsx`
- Create: `apps/admin/components/posts/delete-dialog.tsx`
- Modify: `apps/admin/package.json` (add react-hook-form, @hookform/resolvers)

**Step 1: Install dependencies**

```bash
cd /mnt/c/VelikiBukovec_web/apps/admin && pnpm add react-hook-form @hookform/resolvers
```

**Step 2: Create post form component**

Create `apps/admin/components/posts/post-form.tsx`:
```tsx
'use client';

import { zodResolver } from '@hookform/resolvers/zod';
import { useRouter } from 'next/navigation';
import { useState } from 'react';
import { useForm } from 'react-hook-form';

import { POST_CATEGORY_OPTIONS } from '@repo/shared';
import {
  Button,
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
  Input,
  Label,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Textarea,
  toast,
} from '@repo/ui';

import { createPostSchema, type CreatePostInput } from '@/lib/validations/post';

interface PostFormProps {
  initialData?: {
    id: string;
    title: string;
    content: string;
    excerpt?: string | null;
    category: string;
    isFeatured: boolean;
    publishedAt: string | null;
  };
}

export function PostForm({ initialData }: PostFormProps) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const isEditing = !!initialData;

  const form = useForm<CreatePostInput>({
    resolver: zodResolver(createPostSchema),
    defaultValues: {
      title: initialData?.title ?? '',
      content: initialData?.content ?? '',
      excerpt: initialData?.excerpt ?? '',
      category: (initialData?.category as CreatePostInput['category']) ?? 'aktualnosti',
      isFeatured: initialData?.isFeatured ?? false,
      publishedAt: initialData?.publishedAt ? new Date(initialData.publishedAt) : null,
    },
  });

  const onSubmit = async (data: CreatePostInput) => {
    setIsSubmitting(true);

    try {
      const url = isEditing ? `/api/posts/${initialData.id}` : '/api/posts';
      const method = isEditing ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error ?? 'Greška pri spremanju');
      }

      toast({
        title: isEditing ? 'Objava ažurirana' : 'Objava stvorena',
        type: 'success',
      });

      router.push('/posts');
      router.refresh();
    } catch (error) {
      toast({
        title: 'Greška',
        description: error instanceof Error ? error.message : 'Neočekivana greška',
        type: 'error',
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handlePublish = () => {
    form.setValue('publishedAt', new Date());
    form.handleSubmit(onSubmit)();
  };

  const handleSaveDraft = () => {
    form.setValue('publishedAt', null);
    form.handleSubmit(onSubmit)();
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <div className="grid gap-6 lg:grid-cols-3">
        <div className="lg:col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>Sadržaj objave</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="title">Naslov *</Label>
                <Input
                  id="title"
                  {...form.register('title')}
                  placeholder="Unesite naslov objave"
                />
                {form.formState.errors.title && (
                  <p className="text-sm text-red-600">{form.formState.errors.title.message}</p>
                )}
              </div>

              <div className="space-y-2">
                <Label htmlFor="excerpt">Sažetak</Label>
                <Textarea
                  id="excerpt"
                  {...form.register('excerpt')}
                  placeholder="Kratki sažetak objave (opcionalno)"
                  rows={2}
                />
                {form.formState.errors.excerpt && (
                  <p className="text-sm text-red-600">{form.formState.errors.excerpt.message}</p>
                )}
              </div>

              <div className="space-y-2">
                <Label htmlFor="content">Sadržaj *</Label>
                <Textarea
                  id="content"
                  {...form.register('content')}
                  placeholder="Unesite sadržaj objave (TipTap editor dolazi u Sprintu 1.4)"
                  rows={12}
                />
                {form.formState.errors.content && (
                  <p className="text-sm text-red-600">{form.formState.errors.content.message}</p>
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Postavke</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="category">Kategorija</Label>
                <Select
                  value={form.watch('category')}
                  onValueChange={(value) => form.setValue('category', value as CreatePostInput['category'])}
                >
                  <SelectTrigger id="category">
                    <SelectValue placeholder="Odaberite kategoriju" />
                  </SelectTrigger>
                  <SelectContent>
                    {POST_CATEGORY_OPTIONS.map((opt) => (
                      <SelectItem key={opt.value} value={opt.value}>
                        {opt.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="isFeatured"
                  {...form.register('isFeatured')}
                  className="h-4 w-4 rounded border-neutral-300 text-primary-600 focus:ring-primary-500"
                />
                <Label htmlFor="isFeatured" className="font-normal">
                  Istaknuta objava
                </Label>
              </div>
            </CardContent>
            <CardFooter className="flex flex-col gap-2">
              <Button
                type="button"
                className="w-full"
                onClick={handlePublish}
                disabled={isSubmitting}
              >
                {isSubmitting ? 'Spremanje...' : 'Objavi'}
              </Button>
              <Button
                type="button"
                variant="outline"
                className="w-full"
                onClick={handleSaveDraft}
                disabled={isSubmitting}
              >
                Spremi kao skicu
              </Button>
              <Button
                type="button"
                variant="ghost"
                className="w-full"
                onClick={() => router.back()}
                disabled={isSubmitting}
              >
                Odustani
              </Button>
            </CardFooter>
          </Card>
        </div>
      </div>
    </form>
  );
}
```

**Step 3: Create delete confirmation dialog**

Create `apps/admin/components/posts/delete-dialog.tsx`:
```tsx
'use client';

import { useState } from 'react';

import {
  Button,
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  toast,
} from '@repo/ui';

interface DeleteDialogProps {
  postId: string | null;
  postTitle: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function DeleteDialog({
  postId,
  postTitle,
  open,
  onOpenChange,
  onSuccess,
}: DeleteDialogProps) {
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    if (!postId) return;

    setIsDeleting(true);

    try {
      const response = await fetch(`/api/posts/${postId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error ?? 'Greška pri brisanju');
      }

      toast({
        title: 'Objava obrisana',
        description: `"${postTitle}" je uspješno obrisana.`,
        type: 'success',
      });

      onOpenChange(false);
      onSuccess();
    } catch (error) {
      toast({
        title: 'Greška',
        description: error instanceof Error ? error.message : 'Neočekivana greška',
        type: 'error',
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Obriši objavu</DialogTitle>
          <DialogDescription>
            Jeste li sigurni da želite obrisati objavu &quot;{postTitle}&quot;?
            Ova radnja se ne može poništiti.
          </DialogDescription>
        </DialogHeader>
        <DialogFooter>
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isDeleting}
          >
            Odustani
          </Button>
          <Button
            variant="danger"
            onClick={handleDelete}
            disabled={isDeleting}
          >
            {isDeleting ? 'Brisanje...' : 'Obriši'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

**Step 4: Create barrel export**

Create `apps/admin/components/posts/index.ts`:
```tsx
export { DataTable } from './data-table';
export { PostForm } from './post-form';
export { DeleteDialog } from './delete-dialog';
```

**Step 5: Commit**

```bash
git add apps/admin/components/posts/ apps/admin/package.json pnpm-lock.yaml
git commit -m "feat(posts): add post form and delete dialog components"
```

---

## Task 6: Create Posts List Page

**Files:**
- Modify: `apps/admin/app/(dashboard)/posts/page.tsx`
- Create: `apps/admin/app/(dashboard)/posts/posts-list.tsx`

**Step 1: Create client-side posts list component**

Create `apps/admin/app/(dashboard)/posts/posts-list.tsx`:
```tsx
'use client';

import { Plus } from 'lucide-react';
import Link from 'next/link';
import { useRouter, useSearchParams } from 'next/navigation';
import { useCallback, useEffect, useState } from 'react';

import { Button, Card, CardContent, Toaster } from '@repo/ui';

import { DataTable, DeleteDialog } from '@/components/posts';

interface Post {
  id: string;
  title: string;
  slug: string;
  category: string;
  publishedAt: string | null;
  createdAt: string;
  author: { name: string } | null;
}

interface Pagination {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
}

export function PostsList() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [posts, setPosts] = useState<Post[]>([]);
  const [pagination, setPagination] = useState<Pagination>({
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
  });
  const [isLoading, setIsLoading] = useState(true);
  const [deletePost, setDeletePost] = useState<{ id: string; title: string } | null>(null);

  const filters = {
    search: searchParams.get('search') ?? '',
    category: searchParams.get('category') ?? '',
    status: searchParams.get('status') ?? 'all',
  };
  const page = Number(searchParams.get('page')) || 1;

  const fetchPosts = useCallback(async () => {
    setIsLoading(true);

    const params = new URLSearchParams();
    params.set('page', String(page));
    if (filters.search) params.set('search', filters.search);
    if (filters.category) params.set('category', filters.category);
    if (filters.status !== 'all') params.set('status', filters.status);

    try {
      const response = await fetch(`/api/posts?${params.toString()}`);
      const data = await response.json();

      setPosts(data.posts);
      setPagination(data.pagination);
    } catch (error) {
      console.error('Failed to fetch posts:', error);
    } finally {
      setIsLoading(false);
    }
  }, [page, filters.search, filters.category, filters.status]);

  useEffect(() => {
    fetchPosts();
  }, [fetchPosts]);

  const updateUrl = useCallback(
    (updates: Record<string, string | undefined>) => {
      const params = new URLSearchParams(searchParams.toString());

      Object.entries(updates).forEach(([key, value]) => {
        if (value) {
          params.set(key, value);
        } else {
          params.delete(key);
        }
      });

      // Reset to page 1 when filters change
      if (!updates.page) {
        params.delete('page');
      }

      router.push(`/posts?${params.toString()}`);
    },
    [router, searchParams]
  );

  const handleFiltersChange = (newFilters: { search?: string; category?: string; status?: string }) => {
    updateUrl({
      search: newFilters.search || undefined,
      category: newFilters.category || undefined,
      status: newFilters.status === 'all' ? undefined : newFilters.status,
    });
  };

  const handlePageChange = (newPage: number) => {
    updateUrl({ page: String(newPage) });
  };

  const handleDelete = (id: string, title: string) => {
    setDeletePost({ id, title });
  };

  return (
    <>
      <div className="mb-6 flex items-center justify-between">
        <div>
          <p className="text-neutral-600">
            {pagination.total} {pagination.total === 1 ? 'objava' : 'objava'}
          </p>
        </div>
        <Button asChild>
          <Link href="/posts/new">
            <Plus className="mr-2 h-4 w-4" aria-hidden="true" />
            Nova objava
          </Link>
        </Button>
      </div>

      <Card>
        <CardContent className="p-6">
          <DataTable
            posts={posts}
            pagination={pagination}
            filters={filters}
            onFiltersChange={handleFiltersChange}
            onPageChange={handlePageChange}
            onDelete={handleDelete}
            isLoading={isLoading}
          />
        </CardContent>
      </Card>

      <DeleteDialog
        postId={deletePost?.id ?? null}
        postTitle={deletePost?.title ?? ''}
        open={!!deletePost}
        onOpenChange={(open) => !open && setDeletePost(null)}
        onSuccess={fetchPosts}
      />

      <Toaster />
    </>
  );
}
```

**Step 2: Update posts page**

Modify `apps/admin/app/(dashboard)/posts/page.tsx`:
```tsx
import { Suspense } from 'react';

import { Breadcrumbs } from '@/components/layout';

import { PostsList } from './posts-list';

export default function PostsPage() {
  return (
    <div className="space-y-6">
      <div>
        <h1 className="font-display text-2xl font-bold text-neutral-900 lg:text-3xl">
          Objave
        </h1>
        <Breadcrumbs items={[{ label: 'Objave' }]} className="mt-1" />
      </div>

      <Suspense fallback={<div>Učitavanje...</div>}>
        <PostsList />
      </Suspense>
    </div>
  );
}
```

**Step 3: Commit**

```bash
git add apps/admin/app/\(dashboard\)/posts/
git commit -m "feat(posts): add posts list page with filtering and pagination"
```

---

## Task 7: Create Post Create/Edit Pages

**Files:**
- Create: `apps/admin/app/(dashboard)/posts/new/page.tsx`
- Create: `apps/admin/app/(dashboard)/posts/[id]/page.tsx`

**Step 1: Create new post page**

Create `apps/admin/app/(dashboard)/posts/new/page.tsx`:
```tsx
import { Toaster } from '@repo/ui';

import { Breadcrumbs } from '@/components/layout';
import { PostForm } from '@/components/posts';

export default function NewPostPage() {
  return (
    <div className="space-y-6">
      <div>
        <h1 className="font-display text-2xl font-bold text-neutral-900 lg:text-3xl">
          Nova objava
        </h1>
        <Breadcrumbs
          items={[
            { label: 'Objave', href: '/posts' },
            { label: 'Nova objava' },
          ]}
          className="mt-1"
        />
      </div>

      <PostForm />
      <Toaster />
    </div>
  );
}
```

**Step 2: Create edit post page**

Create `apps/admin/app/(dashboard)/posts/[id]/page.tsx`:
```tsx
import { prisma } from '@repo/database';
import { Toaster } from '@repo/ui';
import { notFound } from 'next/navigation';

import { Breadcrumbs } from '@/components/layout';
import { PostForm } from '@/components/posts';

interface EditPostPageProps {
  params: Promise<{ id: string }>;
}

export default async function EditPostPage({ params }: EditPostPageProps) {
  const { id } = await params;

  const post = await prisma.post.findUnique({
    where: { id },
    select: {
      id: true,
      title: true,
      content: true,
      excerpt: true,
      category: true,
      isFeatured: true,
      publishedAt: true,
    },
  });

  if (!post) {
    notFound();
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="font-display text-2xl font-bold text-neutral-900 lg:text-3xl">
          Uredi objavu
        </h1>
        <Breadcrumbs
          items={[
            { label: 'Objave', href: '/posts' },
            { label: post.title },
          ]}
          className="mt-1"
        />
      </div>

      <PostForm
        initialData={{
          ...post,
          publishedAt: post.publishedAt?.toISOString() ?? null,
        }}
      />
      <Toaster />
    </div>
  );
}
```

**Step 3: Commit**

```bash
git add apps/admin/app/\(dashboard\)/posts/new/ apps/admin/app/\(dashboard\)/posts/\[id\]/
git commit -m "feat(posts): add create and edit post pages"
```

---

## Task 8: Add Toaster to Layout

**Files:**
- Modify: `apps/admin/app/(dashboard)/layout.tsx`

**Step 1: Add Toaster to dashboard layout**

In `apps/admin/app/(dashboard)/layout.tsx`, add the Toaster component to the layout (if not already present from individual pages, this ensures it's available everywhere):

Add import:
```tsx
import { Toaster } from '@repo/ui';
```

Add before closing `</body>` or at the end of the layout content:
```tsx
<Toaster />
```

**Step 2: Commit**

```bash
git add apps/admin/app/\(dashboard\)/layout.tsx
git commit -m "feat(layout): add toaster to dashboard layout"
```

---

## Task 9: Run Gates and Verify

**Step 1: Run all gates**

```bash
cd /mnt/c/VelikiBukovec_web && pnpm lint && pnpm type-check && pnpm test && pnpm build
```

**Step 2: Manual verification**

1. Start the dev server: `pnpm dev`
2. Navigate to http://localhost:3001/posts
3. Verify:
   - Empty state shows "Nema objava"
   - Click "Nova objava" button
   - Fill form, save as draft
   - Verify post appears in list with "Skica" badge
   - Edit the post, publish it
   - Verify "Objavljeno" badge
   - Use filters (category, status, search)
   - Delete the post with confirmation
   - Toast notifications appear on all actions

**Step 3: Commit final state**

```bash
git add -A
git commit -m "chore: sprint 1.3 gate verification complete"
```

---

## Task 10: Update ROADMAP and CHANGELOG

**Files:**
- Modify: `ROADMAP.md`
- Modify: `CHANGELOG.md`

**Step 1: Update ROADMAP.md**

Change Sprint 1.3 status from ⬜ to ✅:
```markdown
| 1.3 ✅ | Posts list + CRUD | 🔀 | 1.1 | Create, read, update, delete posts works |
```

Update active sprint:
```markdown
**Active Sprint:** 1.4 - TipTap editor
**Overall Progress:** 8/71 sprints
```

Update Phase 1 progress:
```markdown
**Status:** In Progress | **Progress:** 3/12 | **Track:** A
```

**Step 2: Update CHANGELOG.md**

Add Sprint 1.3 section:
```markdown
## Sprint 1.3 - Posts List + CRUD (Completed)
- DataTable with filtering by category, status, and search
- Pagination for posts list
- Create post form with title, content, excerpt, category, featured flag
- Edit post with pre-populated form
- Delete post with confirmation dialog
- API routes: GET/POST /api/posts, GET/PUT/DELETE /api/posts/[id]
- Zod validation on client and server
- Toast notifications for all actions
- Loading states throughout
- UI primitives: Table, Dialog, Select, Badge, Textarea, Toast
- Gate: Create post, edit it, find in list, delete it
```

**Step 3: Commit**

```bash
git add ROADMAP.md CHANGELOG.md
git commit -m "docs: update ROADMAP and CHANGELOG for Sprint 1.3 completion"
```

---

## Summary

This plan implements Sprint 1.3 with 10 tasks:

1. **UI Primitives** - Table, Dialog, Select, Badge, Textarea, Toast components
2. **Validation** - Zod schemas and category constants
3. **API Routes** - Full CRUD for posts with filtering and pagination
4. **Data Table** - TanStack Table with columns, pagination, toolbar
5. **Form Components** - Post form and delete dialog
6. **List Page** - Posts list with client-side state management
7. **Create/Edit Pages** - New and edit post routes
8. **Layout Update** - Toaster in dashboard layout
9. **Gates** - Lint, type-check, test, build verification
10. **Documentation** - ROADMAP and CHANGELOG updates

**Gate:** Create post, edit it, find in list, delete it
