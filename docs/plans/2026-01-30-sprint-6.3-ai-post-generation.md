# Sprint 6.3: AI Post Generation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add AI-powered article generation to the post form - user provides instructions and optionally uploads a document (PDF/DOCX/image), AI generates title, content, and excerpt.

**Architecture:** Document parsing happens server-side in API route using pdf-parse, mammoth, and tesseract.js. Parsed text + user instructions are submitted to the existing AI queue. Client polls for completion and populates form fields. UI is a dialog triggered from the post form.

**Tech Stack:** TypeScript, pdf-parse (PDF text), mammoth (DOCX), tesseract.js (OCR), existing AI queue system, React Dialog component

---

## Task 1: Add Document Parsing Dependencies

**Files:**
- Modify: `apps/admin/package.json`

**Step 1: Add dependencies**

Run:
```bash
cd /home/wandeon/WebVB
pnpm --filter=@repo/admin add pdf-parse mammoth tesseract.js
pnpm --filter=@repo/admin add -D @types/pdf-parse
```

**Step 2: Verify installation**

Run: `pnpm install`
Expected: Dependencies installed successfully

**Step 3: Commit**

```bash
git add apps/admin/package.json pnpm-lock.yaml
git commit -m "chore(ai): add document parsing dependencies"
```

---

## Task 2: Create Document Parser Utility

**Files:**
- Create: `apps/admin/lib/ai/document-parser.ts`
- Create: `apps/admin/lib/ai/__tests__/document-parser.test.ts`

**Step 1: Create the document parser**

Create `apps/admin/lib/ai/document-parser.ts`:

```typescript
/**
 * Document Parser
 * Extracts text from PDF, DOCX, and images (OCR)
 */

import mammoth from 'mammoth';
import pdfParse from 'pdf-parse';
import Tesseract from 'tesseract.js';

import { aiLogger } from '../logger';

// =============================================================================
// Types
// =============================================================================

export type SupportedMimeType =
  | 'application/pdf'
  | 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  | 'image/jpeg'
  | 'image/png';

export interface ParseResult {
  success: true;
  text: string;
  pageCount?: number;
  wordCount: number;
}

export interface ParseError {
  success: false;
  error: string;
}

export type ParseDocumentResult = ParseResult | ParseError;

// =============================================================================
// Constants
// =============================================================================

const MAX_TEXT_LENGTH = 8000; // Characters to keep (leave room for prompt)
const SUPPORTED_MIME_TYPES: SupportedMimeType[] = [
  'application/pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'image/jpeg',
  'image/png',
];

// =============================================================================
// Helpers
// =============================================================================

function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  // Truncate at word boundary
  const truncated = text.slice(0, maxLength);
  const lastSpace = truncated.lastIndexOf(' ');
  return lastSpace > maxLength * 0.8
    ? truncated.slice(0, lastSpace) + '...'
    : truncated + '...';
}

function countWords(text: string): number {
  return text.split(/\s+/).filter(Boolean).length;
}

function cleanText(text: string): string {
  return text
    .replace(/\r\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')
    .replace(/[ \t]+/g, ' ')
    .trim();
}

// =============================================================================
// Parsers
// =============================================================================

async function parsePdf(buffer: Buffer): Promise<ParseDocumentResult> {
  try {
    const data = await pdfParse(buffer);
    const text = cleanText(data.text);

    if (!text) {
      // PDF might be scanned - try OCR
      aiLogger.info('PDF has no text, attempting OCR');
      return parseImageOcr(buffer);
    }

    const truncatedText = truncateText(text, MAX_TEXT_LENGTH);

    return {
      success: true,
      text: truncatedText,
      pageCount: data.numpages,
      wordCount: countWords(truncatedText),
    };
  } catch (error) {
    aiLogger.error({ error }, 'Failed to parse PDF');
    return {
      success: false,
      error: 'Nije moguće pročitati PDF dokument',
    };
  }
}

async function parseDocx(buffer: Buffer): Promise<ParseDocumentResult> {
  try {
    const result = await mammoth.extractRawText({ buffer });
    const text = cleanText(result.value);

    if (!text) {
      return {
        success: false,
        error: 'DOCX dokument je prazan',
      };
    }

    const truncatedText = truncateText(text, MAX_TEXT_LENGTH);

    return {
      success: true,
      text: truncatedText,
      wordCount: countWords(truncatedText),
    };
  } catch (error) {
    aiLogger.error({ error }, 'Failed to parse DOCX');
    return {
      success: false,
      error: 'Nije moguće pročitati Word dokument',
    };
  }
}

async function parseImageOcr(buffer: Buffer): Promise<ParseDocumentResult> {
  try {
    const { data } = await Tesseract.recognize(buffer, 'hrv+eng', {
      logger: (m) => {
        if (m.status === 'recognizing text') {
          aiLogger.debug({ progress: m.progress }, 'OCR progress');
        }
      },
    });

    const text = cleanText(data.text);

    if (!text || text.length < 10) {
      return {
        success: false,
        error: 'Nije moguće prepoznati tekst na slici',
      };
    }

    const truncatedText = truncateText(text, MAX_TEXT_LENGTH);

    return {
      success: true,
      text: truncatedText,
      wordCount: countWords(truncatedText),
    };
  } catch (error) {
    aiLogger.error({ error }, 'Failed OCR');
    return {
      success: false,
      error: 'Greška pri prepoznavanju teksta (OCR)',
    };
  }
}

// =============================================================================
// Main Export
// =============================================================================

/**
 * Check if a MIME type is supported for parsing
 */
export function isSupportedMimeType(mimeType: string): mimeType is SupportedMimeType {
  return SUPPORTED_MIME_TYPES.includes(mimeType as SupportedMimeType);
}

/**
 * Get list of supported MIME types
 */
export function getSupportedMimeTypes(): readonly string[] {
  return SUPPORTED_MIME_TYPES;
}

/**
 * Parse a document and extract text
 * Supports PDF, DOCX, and images (with OCR)
 */
export async function parseDocument(
  buffer: Buffer,
  mimeType: string
): Promise<ParseDocumentResult> {
  aiLogger.info({ mimeType, size: buffer.length }, 'Parsing document');

  if (!isSupportedMimeType(mimeType)) {
    return {
      success: false,
      error: `Nepodržani format dokumenta: ${mimeType}`,
    };
  }

  switch (mimeType) {
    case 'application/pdf':
      return parsePdf(buffer);

    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      return parseDocx(buffer);

    case 'image/jpeg':
    case 'image/png':
      return parseImageOcr(buffer);

    default:
      return {
        success: false,
        error: 'Nepodržani format dokumenta',
      };
  }
}
```

**Step 2: Create basic tests**

Create `apps/admin/lib/ai/__tests__/document-parser.test.ts`:

```typescript
import { describe, expect, it } from 'vitest';

import {
  getSupportedMimeTypes,
  isSupportedMimeType,
} from '../document-parser';

describe('document-parser', () => {
  describe('isSupportedMimeType', () => {
    it('returns true for PDF', () => {
      expect(isSupportedMimeType('application/pdf')).toBe(true);
    });

    it('returns true for DOCX', () => {
      expect(
        isSupportedMimeType(
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
      ).toBe(true);
    });

    it('returns true for JPEG', () => {
      expect(isSupportedMimeType('image/jpeg')).toBe(true);
    });

    it('returns true for PNG', () => {
      expect(isSupportedMimeType('image/png')).toBe(true);
    });

    it('returns false for unsupported types', () => {
      expect(isSupportedMimeType('text/plain')).toBe(false);
      expect(isSupportedMimeType('application/json')).toBe(false);
      expect(isSupportedMimeType('video/mp4')).toBe(false);
    });
  });

  describe('getSupportedMimeTypes', () => {
    it('returns array of supported MIME types', () => {
      const types = getSupportedMimeTypes();
      expect(types).toContain('application/pdf');
      expect(types).toContain(
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      );
      expect(types).toContain('image/jpeg');
      expect(types).toContain('image/png');
      expect(types).toHaveLength(4);
    });
  });
});
```

**Step 3: Update AI module exports**

Add to `apps/admin/lib/ai/index.ts`:

```typescript
// Document parser
export {
  parseDocument,
  isSupportedMimeType,
  getSupportedMimeTypes,
  type SupportedMimeType,
  type ParseDocumentResult,
} from './document-parser';
```

**Step 4: Verify**

Run: `pnpm --filter=@repo/admin test`
Expected: Tests pass

Run: `pnpm type-check`
Expected: PASS

**Step 5: Commit**

```bash
git add apps/admin/lib/ai/document-parser.ts apps/admin/lib/ai/__tests__/document-parser.test.ts apps/admin/lib/ai/index.ts
git commit -m "feat(ai): add document parser for PDF, DOCX, and images"
```

---

## Task 3: Create Generate Post API Route

**Files:**
- Create: `apps/admin/app/api/ai/generate-post/route.ts`

**Step 1: Create the API route**

Create `apps/admin/app/api/ai/generate-post/route.ts`:

```typescript
/**
 * POST /api/ai/generate-post
 * Submit a post generation request to the AI queue
 *
 * Accepts multipart/form-data with:
 * - instructions: string (required) - What the article should be about
 * - category: string (required) - Post category for tone/style
 * - document: File (optional) - PDF, DOCX, or image to parse
 */

import { aiQueueRepository } from '@repo/database';

import { parseDocument, isSupportedMimeType } from '@/lib/ai';
import { requireAuth } from '@/lib/api-auth';
import { apiError, apiSuccess, ErrorCodes } from '@/lib/api-response';
import { aiLogger } from '@/lib/logger';

import type { NextRequest } from 'next/server';

// =============================================================================
// Constants
// =============================================================================

const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const MAX_INSTRUCTIONS_LENGTH = 2000;

// =============================================================================
// POST /api/ai/generate-post
// =============================================================================

export async function POST(request: NextRequest) {
  try {
    const authResult = await requireAuth(request);

    if ('response' in authResult) {
      return authResult.response;
    }

    // Parse multipart form data
    const formData = await request.formData();
    const instructions = formData.get('instructions');
    const category = formData.get('category');
    const document = formData.get('document');

    // Validate instructions
    if (!instructions || typeof instructions !== 'string') {
      return apiError(
        ErrorCodes.VALIDATION_ERROR,
        'Upute za članak su obavezne',
        400
      );
    }

    if (instructions.length > MAX_INSTRUCTIONS_LENGTH) {
      return apiError(
        ErrorCodes.VALIDATION_ERROR,
        `Upute ne smiju biti duže od ${MAX_INSTRUCTIONS_LENGTH} znakova`,
        400
      );
    }

    // Validate category
    if (!category || typeof category !== 'string') {
      return apiError(
        ErrorCodes.VALIDATION_ERROR,
        'Kategorija je obavezna',
        400
      );
    }

    // Parse document if provided
    let documentText: string | undefined;

    if (document && document instanceof File) {
      // Validate file size
      if (document.size > MAX_FILE_SIZE) {
        return apiError(
          ErrorCodes.VALIDATION_ERROR,
          'Dokument je prevelik (max 10MB)',
          400
        );
      }

      // Validate file type
      if (!isSupportedMimeType(document.type)) {
        return apiError(
          ErrorCodes.VALIDATION_ERROR,
          'Nepodržani format dokumenta. Dozvoljeni: PDF, DOCX, JPG, PNG',
          400
        );
      }

      // Parse document
      aiLogger.info(
        { fileName: document.name, mimeType: document.type, size: document.size },
        'Parsing uploaded document'
      );

      const buffer = Buffer.from(await document.arrayBuffer());
      const parseResult = await parseDocument(buffer, document.type);

      if (!parseResult.success) {
        return apiError(
          ErrorCodes.VALIDATION_ERROR,
          parseResult.error,
          400
        );
      }

      documentText = parseResult.text;
      aiLogger.info(
        { wordCount: parseResult.wordCount, pageCount: parseResult.pageCount },
        'Document parsed successfully'
      );
    }

    // Build the prompt
    const prompt = buildPrompt(instructions, category, documentText);

    // Create AI queue job
    const job = await aiQueueRepository.create({
      userId: authResult.context.userId,
      requestType: 'post_generation',
      inputData: {
        prompt,
        system: getSystemPrompt(),
        metadata: {
          instructions,
          category,
          hasDocument: Boolean(documentText),
        },
      },
    });

    aiLogger.info(
      { jobId: job.id, hasDocument: Boolean(documentText) },
      'Post generation job created'
    );

    return apiSuccess({ jobId: job.id }, 201);
  } catch (error) {
    aiLogger.error({ error }, 'Greška pri kreiranju AI zadatka za generiranje');
    return apiError(
      ErrorCodes.INTERNAL_ERROR,
      'Greška pri kreiranju AI zadatka',
      500
    );
  }
}

// =============================================================================
// Prompt Building
// =============================================================================

function getSystemPrompt(): string {
  return `Ti si novinar koji piše vijesti za službenu web stranicu Općine Veliki Bukovec.
Piši jasno, informativno i profesionalno na hrvatskom jeziku.
Koristi službeni ton primjeren lokalnoj samoupravi.
Uvijek odgovaraj ISKLJUČIVO u JSON formatu bez dodatnog teksta.`;
}

function buildPrompt(
  instructions: string,
  category: string,
  documentText?: string
): string {
  const categoryHints: Record<string, string> = {
    aktualnosti: 'općeniti informativni ton',
    natjecaji: 'službeni, formalni ton',
    kultura: 'topao, zajednici okrenut ton',
    sport: 'energičan, slavljenički ton',
    obrazovanje: 'informativni, poticajni ton',
    gospodarstvo: 'profesionalni, poslovni ton',
  };

  const toneHint = categoryHints[category] || 'profesionalni ton';

  let prompt = `Napiši članak za kategoriju "${category}" (${toneHint}).

Upute autora:
${instructions}
`;

  if (documentText) {
    prompt += `
Temelji članak na sljedećem dokumentu:
---
${documentText}
---
`;
  }

  prompt += `
Odgovori ISKLJUČIVO u JSON formatu:
{
  "title": "Naslov članka (50-80 znakova, privlačan i informativan)",
  "content": "HTML sadržaj s <p> tagovima, 2-4 odlomka, ~300-500 riječi",
  "excerpt": "Kratki sažetak za prikaz u listi (150-200 znakova)"
}`;

  return prompt;
}
```

**Step 2: Verify**

Run: `pnpm type-check`
Expected: PASS

**Step 3: Commit**

```bash
git add apps/admin/app/api/ai/generate-post/route.ts
git commit -m "feat(ai): add generate-post API route with document parsing"
```

---

## Task 4: Update Queue Worker for Post Generation

**Files:**
- Modify: `apps/admin/lib/ai/queue-worker.ts`

**Step 1: Update processJob to handle post_generation result parsing**

The current worker stores raw response. For post_generation, we need to parse JSON.

Add after the existing imports in `apps/admin/lib/ai/queue-worker.ts`:

```typescript
// Add this interface after the imports
interface PostGenerationResult {
  title: string;
  content: string;
  excerpt: string;
}

function parsePostGenerationResult(response: string): PostGenerationResult | null {
  try {
    // Try to extract JSON from the response (AI might include extra text)
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    const parsed = JSON.parse(jsonMatch[0]) as unknown;

    // Validate structure
    if (
      typeof parsed === 'object' &&
      parsed !== null &&
      'title' in parsed &&
      'content' in parsed &&
      'excerpt' in parsed &&
      typeof (parsed as PostGenerationResult).title === 'string' &&
      typeof (parsed as PostGenerationResult).content === 'string' &&
      typeof (parsed as PostGenerationResult).excerpt === 'string'
    ) {
      return parsed as PostGenerationResult;
    }

    return null;
  } catch {
    return null;
  }
}
```

Then update the success handling in `processJob` function (around line 63-78):

Find this block:
```typescript
  if (result.success) {
    // Success - mark completed with response data
    aiLogger.info(
      { jobId: job.id, model: result.data.model },
      'AI queue job completed successfully'
    );

    await aiQueueRepository.markCompleted(job.id, {
      response: result.data.response,
      model: result.data.model,
      promptTokens: result.data.prompt_eval_count,
      completionTokens: result.data.eval_count,
      totalDurationMs: result.data.total_duration
        ? result.data.total_duration / 1_000_000
        : null,
    });
  }
```

Replace with:
```typescript
  if (result.success) {
    // Success - mark completed with response data
    aiLogger.info(
      { jobId: job.id, model: result.data.model },
      'AI queue job completed successfully'
    );

    // For post_generation, parse the JSON response
    let parsedResult: Record<string, unknown> = {
      response: result.data.response,
    };

    if (job.requestType === 'post_generation') {
      const postResult = parsePostGenerationResult(result.data.response);
      if (postResult) {
        parsedResult = {
          ...parsedResult,
          title: postResult.title,
          content: postResult.content,
          excerpt: postResult.excerpt,
        };
      } else {
        aiLogger.warn(
          { jobId: job.id },
          'Failed to parse post generation result, storing raw response'
        );
      }
    }

    await aiQueueRepository.markCompleted(job.id, {
      ...parsedResult,
      model: result.data.model,
      promptTokens: result.data.prompt_eval_count,
      completionTokens: result.data.eval_count,
      totalDurationMs: result.data.total_duration
        ? result.data.total_duration / 1_000_000
        : null,
    });
  }
```

**Step 2: Verify**

Run: `pnpm type-check`
Expected: PASS

Run: `pnpm --filter=@repo/admin test`
Expected: PASS

**Step 3: Commit**

```bash
git add apps/admin/lib/ai/queue-worker.ts
git commit -m "feat(ai): add post generation result parsing to queue worker"
```

---

## Task 5: Create AI Generate Dialog Component

**Files:**
- Create: `apps/admin/components/posts/ai-generate-dialog.tsx`

**Step 1: Create the dialog component**

Create `apps/admin/components/posts/ai-generate-dialog.tsx`:

```typescript
'use client';

import { POST_CATEGORY_OPTIONS, type PostCategory } from '@repo/shared';
import {
  Button,
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  Label,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Textarea,
  toast,
} from '@repo/ui';
import { FileText, Loader2, Sparkles, Upload, X } from 'lucide-react';
import { useCallback, useEffect, useRef, useState } from 'react';

// =============================================================================
// Types
// =============================================================================

interface AiGenerateDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onGenerated: (result: { title: string; content: string; excerpt: string }) => void;
  defaultCategory?: PostCategory;
}

interface GenerationJob {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: {
    title?: string;
    content?: string;
    excerpt?: string;
  };
  errorMessage?: string;
}

type DialogState = 'form' | 'processing';

// =============================================================================
// Constants
// =============================================================================

const POLL_INTERVAL = 2000; // 2 seconds
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const ACCEPTED_FILE_TYPES = [
  'application/pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'image/jpeg',
  'image/png',
];

// =============================================================================
// Component
// =============================================================================

export function AiGenerateDialog({
  open,
  onOpenChange,
  onGenerated,
  defaultCategory = 'aktualnosti',
}: AiGenerateDialogProps) {
  // Form state
  const [instructions, setInstructions] = useState('');
  const [category, setCategory] = useState<PostCategory>(defaultCategory);
  const [file, setFile] = useState<File | null>(null);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Processing state
  const [dialogState, setDialogState] = useState<DialogState>('form');
  const [jobId, setJobId] = useState<string | null>(null);
  const [statusMessage, setStatusMessage] = useState('');

  // Reset form when dialog closes
  useEffect(() => {
    if (!open) {
      setInstructions('');
      setCategory(defaultCategory);
      setFile(null);
      setDialogState('form');
      setJobId(null);
      setStatusMessage('');
    }
  }, [open, defaultCategory]);

  // Poll for job completion
  useEffect(() => {
    if (!jobId || dialogState !== 'processing') return;

    const pollJob = async () => {
      try {
        const response = await fetch(`/api/ai/queue/${jobId}`);
        const data = (await response.json()) as { success: boolean; data?: GenerationJob };

        if (!data.success || !data.data) return;

        const job = data.data;

        if (job.status === 'processing') {
          setStatusMessage('Generiram sadržaj...');
        } else if (job.status === 'completed') {
          if (job.result?.title && job.result?.content && job.result?.excerpt) {
            onGenerated({
              title: job.result.title,
              content: job.result.content,
              excerpt: job.result.excerpt,
            });
            toast({
              title: 'Uspjeh',
              description: 'Članak je uspješno generiran',
              variant: 'success',
            });
            onOpenChange(false);
          } else {
            toast({
              title: 'Greška',
              description: 'AI nije vratio očekivani format',
              variant: 'destructive',
            });
            setDialogState('form');
          }
        } else if (job.status === 'failed') {
          toast({
            title: 'Greška',
            description: job.errorMessage || 'Generiranje nije uspjelo',
            variant: 'destructive',
          });
          setDialogState('form');
        }
      } catch (error) {
        console.error('Failed to poll job:', error);
      }
    };

    const interval = setInterval(() => void pollJob(), POLL_INTERVAL);
    void pollJob(); // Initial poll

    return () => clearInterval(interval);
  }, [jobId, dialogState, onGenerated, onOpenChange]);

  // File handling
  const handleFileSelect = useCallback((selectedFile: File) => {
    if (selectedFile.size > MAX_FILE_SIZE) {
      toast({
        title: 'Greška',
        description: 'Datoteka je prevelika (max 10MB)',
        variant: 'destructive',
      });
      return;
    }

    if (!ACCEPTED_FILE_TYPES.includes(selectedFile.type)) {
      toast({
        title: 'Greška',
        description: 'Nepodržani format. Dozvoljeni: PDF, DOCX, JPG, PNG',
        variant: 'destructive',
      });
      return;
    }

    setFile(selectedFile);
  }, []);

  const handleDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault();
      setDragActive(false);

      const droppedFile = e.dataTransfer.files[0];
      if (droppedFile) {
        handleFileSelect(droppedFile);
      }
    },
    [handleFileSelect]
  );

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(false);
  }, []);

  const handleFileInputChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const selectedFile = e.target.files?.[0];
      if (selectedFile) {
        handleFileSelect(selectedFile);
      }
    },
    [handleFileSelect]
  );

  const removeFile = useCallback(() => {
    setFile(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, []);

  // Submit handler
  const handleSubmit = async () => {
    if (!instructions.trim()) {
      toast({
        title: 'Greška',
        description: 'Upute za članak su obavezne',
        variant: 'destructive',
      });
      return;
    }

    setDialogState('processing');
    setStatusMessage(file ? 'Obrađujem dokument...' : 'Šaljem zahtjev...');

    try {
      const formData = new FormData();
      formData.append('instructions', instructions);
      formData.append('category', category);
      if (file) {
        formData.append('document', file);
      }

      const response = await fetch('/api/ai/generate-post', {
        method: 'POST',
        body: formData,
      });

      const data = (await response.json()) as {
        success: boolean;
        data?: { jobId: string };
        error?: { message: string };
      };

      if (!data.success) {
        throw new Error(data.error?.message || 'Greška pri slanju zahtjeva');
      }

      setJobId(data.data!.jobId);
      setStatusMessage('Čekam u redu...');
    } catch (error) {
      toast({
        title: 'Greška',
        description: error instanceof Error ? error.message : 'Greška pri slanju zahtjeva',
        variant: 'destructive',
      });
      setDialogState('form');
    }
  };

  // Cancel handler
  const handleCancel = () => {
    if (dialogState === 'processing' && jobId) {
      // Could cancel the job here if needed
      void fetch(`/api/ai/queue/${jobId}`, { method: 'DELETE' });
    }
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Sparkles className="h-5 w-5 text-primary-600" />
            Generiraj članak s AI
          </DialogTitle>
          <DialogDescription>
            Opišite što želite napisati, a AI će generirati naslov, sadržaj i sažetak.
          </DialogDescription>
        </DialogHeader>

        {dialogState === 'form' ? (
          <>
            <div className="space-y-4 py-4">
              {/* Instructions textarea */}
              <div className="space-y-2">
                <Label htmlFor="instructions" required>
                  Upute za članak
                </Label>
                <Textarea
                  id="instructions"
                  placeholder="Napiši vijest o otvaranju novog dječjeg parka. Naglasi ulaganje općine i pogodnosti za mlade obitelji..."
                  rows={5}
                  value={instructions}
                  onChange={(e) => setInstructions(e.target.value)}
                  maxLength={2000}
                />
                <p className="text-xs text-neutral-500">
                  Opišite temu, kut članka i ključne informacije ({instructions.length}/2000)
                </p>
              </div>

              {/* Category select */}
              <div className="space-y-2">
                <Label htmlFor="category" required>
                  Kategorija
                </Label>
                <Select value={category} onValueChange={(v) => setCategory(v as PostCategory)}>
                  <SelectTrigger id="category">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {POST_CATEGORY_OPTIONS.map((opt) => (
                      <SelectItem key={opt.value} value={opt.value}>
                        {opt.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* File upload */}
              <div className="space-y-2">
                <Label>Dokument (opcionalno)</Label>
                {file ? (
                  <div className="flex items-center gap-2 rounded-lg border border-neutral-200 bg-neutral-50 p-3">
                    <FileText className="h-5 w-5 text-neutral-600" />
                    <span className="flex-1 truncate text-sm">{file.name}</span>
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={removeFile}
                      className="h-8 w-8 p-0"
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                ) : (
                  <div
                    className={`flex cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed p-6 transition-colors ${
                      dragActive
                        ? 'border-primary-500 bg-primary-50'
                        : 'border-neutral-300 hover:border-neutral-400'
                    }`}
                    onDrop={handleDrop}
                    onDragOver={handleDragOver}
                    onDragLeave={handleDragLeave}
                    onClick={() => fileInputRef.current?.click()}
                  >
                    <Upload className="mb-2 h-8 w-8 text-neutral-400" />
                    <p className="text-sm text-neutral-600">
                      Povucite datoteku ili kliknite za odabir
                    </p>
                    <p className="mt-1 text-xs text-neutral-500">
                      PDF, DOCX, JPG, PNG (max 10MB)
                    </p>
                    <input
                      ref={fileInputRef}
                      type="file"
                      className="hidden"
                      accept=".pdf,.docx,.jpg,.jpeg,.png"
                      onChange={handleFileInputChange}
                    />
                  </div>
                )}
              </div>
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={handleCancel}>
                Odustani
              </Button>
              <Button
                type="button"
                onClick={() => void handleSubmit()}
                disabled={!instructions.trim()}
              >
                <Sparkles className="mr-2 h-4 w-4" />
                Generiraj
              </Button>
            </DialogFooter>
          </>
        ) : (
          <div className="flex flex-col items-center justify-center py-12">
            <Loader2 className="mb-4 h-12 w-12 animate-spin text-primary-600" />
            <p className="text-lg font-medium">{statusMessage}</p>
            <p className="mt-2 text-sm text-neutral-500">
              Ovo može potrajati do minutu...
            </p>
            <Button
              type="button"
              variant="outline"
              onClick={handleCancel}
              className="mt-6"
            >
              Odustani
            </Button>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}
```

**Step 2: Verify**

Run: `pnpm type-check`
Expected: PASS

**Step 3: Commit**

```bash
git add apps/admin/components/posts/ai-generate-dialog.tsx
git commit -m "feat(ai): add AI generate dialog component for posts"
```

---

## Task 6: Create AI Generate Button Component

**Files:**
- Create: `apps/admin/components/posts/ai-generate-button.tsx`

**Step 1: Create the button component**

Create `apps/admin/components/posts/ai-generate-button.tsx`:

```typescript
'use client';

import type { PostCategory } from '@repo/shared';
import { Button, toast } from '@repo/ui';
import { Sparkles } from 'lucide-react';
import { useEffect, useState } from 'react';

import { AiGenerateDialog } from './ai-generate-dialog';

interface AiGenerateButtonProps {
  onGenerated: (result: { title: string; content: string; excerpt: string }) => void;
  category?: PostCategory;
  disabled?: boolean;
}

export function AiGenerateButton({
  onGenerated,
  category = 'aktualnosti',
  disabled = false,
}: AiGenerateButtonProps) {
  const [dialogOpen, setDialogOpen] = useState(false);
  const [isConfigured, setIsConfigured] = useState<boolean | null>(null);

  // Check if AI is configured on mount
  useEffect(() => {
    const checkConfig = async () => {
      try {
        const response = await fetch('/api/ai/queue/stats');
        const data = (await response.json()) as {
          success: boolean;
          data?: { ollamaConfigured: boolean };
        };
        setIsConfigured(data.data?.ollamaConfigured ?? false);
      } catch {
        setIsConfigured(false);
      }
    };

    void checkConfig();
  }, []);

  const handleClick = () => {
    if (!isConfigured) {
      toast({
        title: 'AI nije dostupan',
        description: 'Ollama Cloud nije konfiguriran. Kontaktirajte administratora.',
        variant: 'destructive',
      });
      return;
    }
    setDialogOpen(true);
  };

  return (
    <>
      <Button
        type="button"
        variant="outline"
        onClick={handleClick}
        disabled={disabled || isConfigured === false}
        title={isConfigured === false ? 'AI nije konfiguriran' : 'Generiraj sadržaj s AI'}
      >
        <Sparkles className="mr-2 h-4 w-4" />
        Generiraj s AI
      </Button>

      <AiGenerateDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        onGenerated={onGenerated}
        defaultCategory={category}
      />
    </>
  );
}
```

**Step 2: Verify**

Run: `pnpm type-check`
Expected: PASS

**Step 3: Commit**

```bash
git add apps/admin/components/posts/ai-generate-button.tsx
git commit -m "feat(ai): add AI generate button component"
```

---

## Task 7: Integrate AI Generation into Post Form

**Files:**
- Modify: `apps/admin/components/posts/post-form.tsx`

**Step 1: Import the AI generate button**

Add to the imports at the top of `post-form.tsx`:

```typescript
import { AiGenerateButton } from './ai-generate-button';
```

**Step 2: Add the AI generate button to the form**

Find the title input section (around line 156-170):

```typescript
            {/* Title */}
            <div className="space-y-2">
              <Label htmlFor="title" required>
                Naslov
              </Label>
```

Add the AI button before the title input, replacing the block with:

```typescript
            {/* AI Generate Button */}
            <div className="flex justify-end">
              <AiGenerateButton
                category={category}
                disabled={isSubmitting}
                onGenerated={(result) => {
                  setValue('title', result.title, { shouldValidate: true });
                  setValue('content', result.content, { shouldValidate: true });
                  setValue('excerpt', result.excerpt, { shouldValidate: true });
                }}
              />
            </div>

            {/* Title */}
            <div className="space-y-2">
              <Label htmlFor="title" required>
                Naslov
              </Label>
```

**Step 3: Verify**

Run: `pnpm type-check`
Expected: PASS

**Step 4: Commit**

```bash
git add apps/admin/components/posts/post-form.tsx
git commit -m "feat(ai): integrate AI generation into post form"
```

---

## Task 8: Final Verification

**Step 1: Run all checks**

```bash
cd /home/wandeon/WebVB
pnpm type-check
pnpm lint --filter=@repo/admin
pnpm --filter=@repo/admin test
```

Expected: All commands pass (lint may have pre-existing warnings)

**Step 2: Verify file structure**

```bash
ls -la apps/admin/lib/ai/
ls -la apps/admin/app/api/ai/generate-post/
ls -la apps/admin/components/posts/ai-*.tsx
```

Expected:
- `apps/admin/lib/ai/document-parser.ts` exists
- `apps/admin/app/api/ai/generate-post/route.ts` exists
- `apps/admin/components/posts/ai-generate-button.tsx` exists
- `apps/admin/components/posts/ai-generate-dialog.tsx` exists

**Step 3: Manual testing (when Ollama quota available)**

1. Start admin app: `pnpm dev --filter=@repo/admin`
2. Navigate to /posts/new
3. Click "Generiraj s AI" button
4. Enter instructions: "Napiši vijest o otvaranju novog parka u Velikom Bukovcu. Naglasi da je projekt koštao 500.000 kuna i da ima igralište za djecu."
5. Select category: Aktualnosti
6. Click "Generiraj"
7. Wait for completion
8. Verify title, content, excerpt are populated in the form
9. Test with PDF document upload

---

## Summary

| Task | Description |
|------|-------------|
| 1 | Add document parsing dependencies (pdf-parse, mammoth, tesseract.js) |
| 2 | Create document parser utility |
| 3 | Create generate-post API route |
| 4 | Update queue worker for post generation result parsing |
| 5 | Create AI generate dialog component |
| 6 | Create AI generate button component |
| 7 | Integrate into post form |
| 8 | Final verification |

## Files Created/Modified

**Created:**
- `apps/admin/lib/ai/document-parser.ts` - Document parsing utility
- `apps/admin/lib/ai/__tests__/document-parser.test.ts` - Parser tests
- `apps/admin/app/api/ai/generate-post/route.ts` - API route
- `apps/admin/components/posts/ai-generate-dialog.tsx` - Generation dialog
- `apps/admin/components/posts/ai-generate-button.tsx` - Trigger button

**Modified:**
- `apps/admin/package.json` - New dependencies
- `apps/admin/lib/ai/index.ts` - Export document parser
- `apps/admin/lib/ai/queue-worker.ts` - Parse post generation results
- `apps/admin/components/posts/post-form.tsx` - Add AI button
