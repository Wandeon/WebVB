# Sprint 4.5.1: Content Sitemap & Inventory Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create a comprehensive inventory of all content in the system - database counts, route mappings, and content status assessment.

**Architecture:** Query database repositories for content counts, scan codebase for all routes, cross-reference to identify gaps, output a structured markdown inventory document.

**Tech Stack:** TypeScript, Prisma repositories, Node.js script, Markdown output

---

## Task 1: Create Content Directory Structure

**Files:**
- Create: `docs/content/` directory
- Create: `docs/content/README.md`

**Step 1: Create directory and README**

```bash
mkdir -p docs/content
```

Create `docs/content/README.md`:

```markdown
# Content Documentation

This directory contains content audits, inventories, and quality assessments.

## Documents

| File | Description |
|------|-------------|
| `sitemap-inventory.md` | Complete content inventory with counts and status |
| `old-vs-new-comparison.md` | Migration parity report (Sprint 4.5.2) |
| `quality-audit.md` | Content quality scores (Sprint 4.5.3) |
| `enrichment-plan.md` | Prioritized improvement tasks (Sprint 4.5.4) |

## Last Updated

- Sprint 4.5.1: 2026-01-30
```

**Step 2: Commit**

```bash
git add docs/content/
git commit -m "docs: create content documentation directory"
```

---

## Task 2: Create Content Inventory Script

**Files:**
- Create: `scripts/content-inventory.ts`

**Step 1: Create the inventory script**

Create `scripts/content-inventory.ts`:

```typescript
/**
 * Content Inventory Script
 * Queries all database tables and outputs content statistics
 *
 * Run: pnpm tsx scripts/content-inventory.ts
 */

import { db } from '../packages/database/src/client';

interface ContentStats {
  posts: {
    total: number;
    published: number;
    draft: number;
    featured: number;
    byCategory: Record<string, number>;
  };
  announcements: {
    total: number;
    published: number;
    active: number;
    expired: number;
    withAttachments: number;
    byCategory: Record<string, number>;
  };
  documents: {
    total: number;
    byCategory: Record<string, number>;
    byYear: Record<string, number>;
  };
  pages: {
    total: number;
    withContent: number;
    empty: number;
    topLevel: number;
    nested: number;
  };
  events: {
    total: number;
    upcoming: number;
    past: number;
    withPoster: number;
  };
  galleries: {
    total: number;
    totalImages: number;
    avgImagesPerGallery: number;
  };
  searchIndex: {
    total: number;
    bySourceType: Record<string, number>;
  };
  users: {
    total: number;
    byRole: Record<string, number>;
  };
  communication: {
    contactMessages: number;
    problemReports: number;
    newsletterSubscribers: number;
    confirmedSubscribers: number;
  };
}

async function getContentStats(): Promise<ContentStats> {
  const now = new Date();

  // Posts
  const posts = await db.post.findMany({
    select: { id: true, publishedAt: true, isFeatured: true, category: true },
  });
  const postsByCategory: Record<string, number> = {};
  posts.forEach(p => {
    postsByCategory[p.category] = (postsByCategory[p.category] || 0) + 1;
  });

  // Announcements
  const announcements = await db.announcement.findMany({
    select: { id: true, publishedAt: true, validFrom: true, validUntil: true, category: true },
    include: { _count: { select: { attachments: true } } },
  });
  const annByCategory: Record<string, number> = {};
  announcements.forEach(a => {
    annByCategory[a.category] = (annByCategory[a.category] || 0) + 1;
  });
  const activeAnnouncements = announcements.filter(a => {
    if (!a.publishedAt) return false;
    if (a.validFrom && a.validFrom > now) return false;
    if (a.validUntil && a.validUntil < now) return false;
    return true;
  });

  // Documents
  const documents = await db.document.findMany({
    select: { id: true, category: true, year: true },
  });
  const docsByCategory: Record<string, number> = {};
  const docsByYear: Record<string, number> = {};
  documents.forEach(d => {
    docsByCategory[d.category] = (docsByCategory[d.category] || 0) + 1;
    if (d.year) {
      docsByYear[d.year.toString()] = (docsByYear[d.year.toString()] || 0) + 1;
    }
  });

  // Pages
  const pages = await db.page.findMany({
    select: { id: true, content: true, parentId: true },
  });
  const pagesWithContent = pages.filter(p => p.content && p.content.trim().length > 50);
  const emptyPages = pages.filter(p => !p.content || p.content.trim().length <= 50);
  const topLevelPages = pages.filter(p => !p.parentId);

  // Events
  const events = await db.event.findMany({
    select: { id: true, eventDate: true, posterImage: true },
  });
  const upcomingEvents = events.filter(e => e.eventDate >= now);

  // Galleries
  const galleries = await db.gallery.findMany({
    include: { _count: { select: { images: true } } },
  });
  const totalImages = galleries.reduce((sum, g) => sum + g._count.images, 0);

  // Search Index
  const searchIndexCounts = await db.searchIndex.groupBy({
    by: ['sourceType'],
    _count: true,
  });
  const bySourceType: Record<string, number> = {};
  searchIndexCounts.forEach(s => {
    bySourceType[s.sourceType] = s._count;
  });

  // Users
  const users = await db.user.findMany({
    select: { id: true, role: true },
  });
  const usersByRole: Record<string, number> = {};
  users.forEach(u => {
    usersByRole[u.role] = (usersByRole[u.role] || 0) + 1;
  });

  // Communication
  const contactMessages = await db.contactMessage.count();
  const problemReports = await db.problemReport.count();
  const newsletterSubscribers = await db.newsletterSubscriber.count();
  const confirmedSubscribers = await db.newsletterSubscriber.count({
    where: { confirmed: true, unsubscribedAt: null },
  });

  return {
    posts: {
      total: posts.length,
      published: posts.filter(p => p.publishedAt).length,
      draft: posts.filter(p => !p.publishedAt).length,
      featured: posts.filter(p => p.isFeatured).length,
      byCategory: postsByCategory,
    },
    announcements: {
      total: announcements.length,
      published: announcements.filter(a => a.publishedAt).length,
      active: activeAnnouncements.length,
      expired: announcements.filter(a => a.validUntil && a.validUntil < now).length,
      withAttachments: announcements.filter(a => a._count.attachments > 0).length,
      byCategory: annByCategory,
    },
    documents: {
      total: documents.length,
      byCategory: docsByCategory,
      byYear: docsByYear,
    },
    pages: {
      total: pages.length,
      withContent: pagesWithContent.length,
      empty: emptyPages.length,
      topLevel: topLevelPages.length,
      nested: pages.length - topLevelPages.length,
    },
    events: {
      total: events.length,
      upcoming: upcomingEvents.length,
      past: events.length - upcomingEvents.length,
      withPoster: events.filter(e => e.posterImage).length,
    },
    galleries: {
      total: galleries.length,
      totalImages,
      avgImagesPerGallery: galleries.length > 0 ? Math.round(totalImages / galleries.length) : 0,
    },
    searchIndex: {
      total: searchIndexCounts.reduce((sum, s) => sum + s._count, 0),
      bySourceType,
    },
    users: {
      total: users.length,
      byRole: usersByRole,
    },
    communication: {
      contactMessages,
      problemReports,
      newsletterSubscribers,
      confirmedSubscribers,
    },
  };
}

function generateMarkdown(stats: ContentStats): string {
  const now = new Date().toISOString().split('T')[0];

  return `# Content Sitemap & Inventory

> Generated: ${now}
> Sprint: 4.5.1

---

## Executive Summary

| Content Type | Count | Status |
|--------------|-------|--------|
| Posts (Vijesti) | ${stats.posts.total} | ${stats.posts.published} published, ${stats.posts.draft} draft |
| Announcements (Obavijesti) | ${stats.announcements.total} | ${stats.announcements.active} active, ${stats.announcements.expired} expired |
| Documents | ${stats.documents.total} | Across ${Object.keys(stats.documents.byCategory).length} categories |
| Pages (Stranice) | ${stats.pages.total} | ${stats.pages.withContent} with content, ${stats.pages.empty} empty |
| Events (Dogaƒëanja) | ${stats.events.total} | ${stats.events.upcoming} upcoming, ${stats.events.past} past |
| Galleries | ${stats.galleries.total} | ${stats.galleries.totalImages} total images |
| **Total Content Items** | **${stats.posts.total + stats.announcements.total + stats.documents.total + stats.pages.total + stats.events.total + stats.galleries.total}** | |

---

## 1. Posts (Vijesti)

**Total:** ${stats.posts.total} posts

| Metric | Count |
|--------|-------|
| Published | ${stats.posts.published} |
| Draft | ${stats.posts.draft} |
| Featured | ${stats.posts.featured} |

### By Category

| Category | Count |
|----------|-------|
${Object.entries(stats.posts.byCategory)
  .sort((a, b) => b[1] - a[1])
  .map(([cat, count]) => `| ${cat} | ${count} |`)
  .join('\n')}

---

## 2. Announcements (Obavijesti)

**Total:** ${stats.announcements.total} announcements

| Metric | Count |
|--------|-------|
| Published | ${stats.announcements.published} |
| Currently Active | ${stats.announcements.active} |
| Expired | ${stats.announcements.expired} |
| With Attachments | ${stats.announcements.withAttachments} |

### By Category

| Category | Count |
|----------|-------|
${Object.entries(stats.announcements.byCategory)
  .sort((a, b) => b[1] - a[1])
  .map(([cat, count]) => `| ${cat} | ${count} |`)
  .join('\n')}

---

## 3. Documents

**Total:** ${stats.documents.total} documents

### By Category

| Category | Count |
|----------|-------|
${Object.entries(stats.documents.byCategory)
  .sort((a, b) => b[1] - a[1])
  .map(([cat, count]) => `| ${cat} | ${count} |`)
  .join('\n')}

### By Year

| Year | Count |
|------|-------|
${Object.entries(stats.documents.byYear)
  .sort((a, b) => parseInt(b[0]) - parseInt(a[0]))
  .map(([year, count]) => `| ${year} | ${count} |`)
  .join('\n')}

---

## 4. Pages (Stranice)

**Total:** ${stats.pages.total} pages

| Metric | Count |
|--------|-------|
| With Content (>50 chars) | ${stats.pages.withContent} |
| Empty/Placeholder | ${stats.pages.empty} |
| Top-Level | ${stats.pages.topLevel} |
| Nested (with parent) | ${stats.pages.nested} |

---

## 5. Events (Dogaƒëanja)

**Total:** ${stats.events.total} events

| Metric | Count |
|--------|-------|
| Upcoming | ${stats.events.upcoming} |
| Past | ${stats.events.past} |
| With Poster Image | ${stats.events.withPoster} |

---

## 6. Galleries

**Total:** ${stats.galleries.total} galleries

| Metric | Count |
|--------|-------|
| Total Images | ${stats.galleries.totalImages} |
| Avg Images/Gallery | ${stats.galleries.avgImagesPerGallery} |

---

## 7. Search Index

**Total Indexed:** ${stats.searchIndex.total} items

| Source Type | Count |
|-------------|-------|
${Object.entries(stats.searchIndex.bySourceType)
  .sort((a, b) => b[1] - a[1])
  .map(([type, count]) => `| ${type} | ${count} |`)
  .join('\n')}

---

## 8. Users & Communication

### Users

| Role | Count |
|------|-------|
${Object.entries(stats.users.byRole)
  .map(([role, count]) => `| ${role} | ${count} |`)
  .join('\n')}

### Communication

| Type | Count |
|------|-------|
| Contact Messages | ${stats.communication.contactMessages} |
| Problem Reports | ${stats.communication.problemReports} |
| Newsletter Subscribers | ${stats.communication.newsletterSubscribers} |
| Confirmed Subscribers | ${stats.communication.confirmedSubscribers} |

---

## Route Inventory

### Public Web Routes (apps/web)

| Route | Content Type | Status |
|-------|--------------|--------|
| \`/\` | Homepage | ‚úÖ Dynamic |
| \`/vijesti\` | Posts List | ‚úÖ ${stats.posts.published} items |
| \`/vijesti/[slug]\` | Post Detail | ‚úÖ Dynamic |
| \`/obavijesti\` | Announcements List | ‚úÖ ${stats.announcements.active} active |
| \`/obavijesti/[slug]\` | Announcement Detail | ‚úÖ Dynamic |
| \`/dokumenti\` | Documents List | ‚úÖ ${stats.documents.total} items |
| \`/dogadanja\` | Events Calendar | ‚úÖ ${stats.events.total} items |
| \`/dogadanja/[id]\` | Event Detail | ‚úÖ Dynamic |
| \`/galerija\` | Galleries List | ‚úÖ ${stats.galleries.total} items |
| \`/galerija/[slug]\` | Gallery Detail | ‚úÖ Dynamic |
| \`/kontakt\` | Contact Form | ‚úÖ Static |
| \`/prijava-problema\` | Problem Report | ‚úÖ Static |
| \`/opcina\` | About (Tabs) | ‚úÖ Consolidated |
| \`/opcina/naselja\` | Settlements | ‚úÖ Consolidated |
| \`/opcina/udruge\` | Organizations | ‚úÖ Consolidated |
| \`/organizacija\` | Organization | ‚úÖ Consolidated |
| \`/usluge\` | Services | ‚úÖ Consolidated |
| \`/izbori\` | Elections | ‚úÖ Consolidated |
| \`/newsletter/potvrda\` | Newsletter Confirm | ‚úÖ Static |
| \`/newsletter/odjava\` | Newsletter Unsubscribe | ‚úÖ Static |
| \`/[...slug]\` | Legacy Pages | ‚úÖ ${stats.pages.total} pages |

### Admin Routes (apps/admin)

| Route | Purpose | Status |
|-------|---------|--------|
| \`/login\` | Authentication | ‚úÖ |
| \`/(dashboard)\` | Dashboard | ‚úÖ |
| \`/posts\` | Post Management | ‚úÖ ${stats.posts.total} |
| \`/announcements\` | Announcement Management | ‚úÖ ${stats.announcements.total} |
| \`/documents\` | Document Management | ‚úÖ ${stats.documents.total} |
| \`/events\` | Event Management | ‚úÖ ${stats.events.total} |
| \`/galleries\` | Gallery Management | ‚úÖ ${stats.galleries.total} |
| \`/pages\` | Page Management | ‚úÖ ${stats.pages.total} |
| \`/users\` | User Management | ‚úÖ ${stats.users.total} |
| \`/newsletter\` | Newsletter | ‚úÖ |
| \`/settings\` | Settings | ‚úÖ |
| \`/messages\` | Contact Inbox | ‚úÖ ${stats.communication.contactMessages} |
| \`/reports\` | Problem Reports | ‚úÖ ${stats.communication.problemReports} |
| \`/ai\` | AI Queue | ‚úÖ |

---

## Content Status Summary

### Complete ‚úÖ
- Posts system with categories and publishing
- Announcements with validity dates and attachments
- Documents with categories and years
- Events with calendar integration
- Galleries with image management
- Search indexing and full-text search
- Newsletter system with double opt-in
- Contact and problem report forms

### Needs Review üîç
- ${stats.pages.empty} empty pages need content
- ${stats.posts.draft} draft posts need publishing decision
- ${stats.announcements.expired} expired announcements - archive or delete?

### Metrics
- **Total Content Items:** ${stats.posts.total + stats.announcements.total + stats.documents.total + stats.pages.total + stats.events.total + stats.galleries.total}
- **Search Indexed:** ${stats.searchIndex.total}
- **Content Coverage:** ${Math.round((stats.searchIndex.total / (stats.posts.total + stats.documents.total + stats.pages.total + stats.events.total)) * 100)}%
`;
}

async function main() {
  console.log('Gathering content statistics...');

  try {
    const stats = await getContentStats();
    const markdown = generateMarkdown(stats);

    // Write to file
    const fs = await import('fs/promises');
    await fs.writeFile('docs/content/sitemap-inventory.md', markdown);

    console.log('Content inventory generated: docs/content/sitemap-inventory.md');
    console.log('\nSummary:');
    console.log(`- Posts: ${stats.posts.total} (${stats.posts.published} published)`);
    console.log(`- Announcements: ${stats.announcements.total} (${stats.announcements.active} active)`);
    console.log(`- Documents: ${stats.documents.total}`);
    console.log(`- Pages: ${stats.pages.total} (${stats.pages.empty} empty)`);
    console.log(`- Events: ${stats.events.total}`);
    console.log(`- Galleries: ${stats.galleries.total} (${stats.galleries.totalImages} images)`);
  } catch (error) {
    console.error('Error generating inventory:', error);
    process.exit(1);
  } finally {
    await db.$disconnect();
  }
}

main();
```

**Step 2: Run the script to verify it works**

```bash
pnpm tsx scripts/content-inventory.ts
```

Expected: Script outputs summary and creates `docs/content/sitemap-inventory.md`

**Step 3: Commit**

```bash
git add scripts/content-inventory.ts
git commit -m "feat: add content inventory script"
```

---

## Task 3: Run Inventory and Review Output

**Files:**
- Read: `docs/content/sitemap-inventory.md` (generated)

**Step 1: Execute the script against production database**

Ensure DATABASE_URL is set to production (via Tailscale):

```bash
pnpm tsx scripts/content-inventory.ts
```

**Step 2: Review the generated inventory**

Open `docs/content/sitemap-inventory.md` and verify:
- All counts are realistic (not 0 or error)
- Categories match expected values
- Routes are correctly mapped
- Status assessments are accurate

**Step 3: Commit the generated inventory**

```bash
git add docs/content/sitemap-inventory.md
git commit -m "docs: generate content inventory for Sprint 4.5.1"
```

---

## Task 4: Identify Empty/Placeholder Content

**Files:**
- Create: `scripts/find-empty-content.ts`

**Step 1: Create script to find empty/thin content**

Create `scripts/find-empty-content.ts`:

```typescript
/**
 * Find Empty/Placeholder Content
 * Identifies pages and posts that need content
 *
 * Run: pnpm tsx scripts/find-empty-content.ts
 */

import { db } from '../packages/database/src/client';

const PLACEHOLDER_PATTERNS = [
  /lorem ipsum/i,
  /todo/i,
  /tbd/i,
  /placeholder/i,
  /coming soon/i,
  /uskoro/i,
  /u izradi/i,
];

interface ContentIssue {
  type: 'page' | 'post' | 'announcement';
  id: string;
  title: string;
  issue: 'empty' | 'too_short' | 'placeholder';
  wordCount: number;
  url: string;
}

function countWords(html: string): number {
  // Strip HTML tags
  const text = html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
  return text.split(' ').filter(w => w.length > 0).length;
}

function hasPlaceholder(content: string): boolean {
  return PLACEHOLDER_PATTERNS.some(pattern => pattern.test(content));
}

async function findIssues(): Promise<ContentIssue[]> {
  const issues: ContentIssue[] = [];

  // Check pages
  const pages = await db.page.findMany({
    select: { id: true, title: true, slug: true, content: true },
  });

  for (const page of pages) {
    const wordCount = page.content ? countWords(page.content) : 0;

    if (!page.content || wordCount === 0) {
      issues.push({
        type: 'page',
        id: page.id,
        title: page.title,
        issue: 'empty',
        wordCount: 0,
        url: `/${page.slug}`,
      });
    } else if (wordCount < 50) {
      issues.push({
        type: 'page',
        id: page.id,
        title: page.title,
        issue: 'too_short',
        wordCount,
        url: `/${page.slug}`,
      });
    } else if (hasPlaceholder(page.content)) {
      issues.push({
        type: 'page',
        id: page.id,
        title: page.title,
        issue: 'placeholder',
        wordCount,
        url: `/${page.slug}`,
      });
    }
  }

  // Check posts (drafts only - published assumed OK)
  const drafts = await db.post.findMany({
    where: { publishedAt: null },
    select: { id: true, title: true, slug: true, content: true },
  });

  for (const post of drafts) {
    const wordCount = post.content ? countWords(post.content) : 0;

    if (!post.content || wordCount === 0) {
      issues.push({
        type: 'post',
        id: post.id,
        title: post.title,
        issue: 'empty',
        wordCount: 0,
        url: `/vijesti/${post.slug}`,
      });
    } else if (wordCount < 100) {
      issues.push({
        type: 'post',
        id: post.id,
        title: post.title,
        issue: 'too_short',
        wordCount,
        url: `/vijesti/${post.slug}`,
      });
    }
  }

  return issues;
}

async function main() {
  console.log('Scanning for empty/placeholder content...\n');

  try {
    const issues = await findIssues();

    if (issues.length === 0) {
      console.log('No content issues found!');
      return;
    }

    console.log(`Found ${issues.length} content issues:\n`);

    // Group by type
    const byType = issues.reduce((acc, issue) => {
      acc[issue.type] = acc[issue.type] || [];
      acc[issue.type].push(issue);
      return acc;
    }, {} as Record<string, ContentIssue[]>);

    for (const [type, typeIssues] of Object.entries(byType)) {
      console.log(`\n## ${type.toUpperCase()} (${typeIssues.length} issues)\n`);

      for (const issue of typeIssues) {
        const emoji = issue.issue === 'empty' ? 'üî¥' : issue.issue === 'placeholder' ? 'üü°' : 'üü†';
        console.log(`${emoji} [${issue.issue}] ${issue.title}`);
        console.log(`   Words: ${issue.wordCount} | URL: ${issue.url}`);
      }
    }

    // Output as markdown appendix
    const fs = await import('fs/promises');
    const markdown = `

---

## Content Issues Detected

> Auto-generated by \`scripts/find-empty-content.ts\`

### Summary

| Issue Type | Count |
|------------|-------|
| Empty | ${issues.filter(i => i.issue === 'empty').length} |
| Too Short (<50-100 words) | ${issues.filter(i => i.issue === 'too_short').length} |
| Contains Placeholder | ${issues.filter(i => i.issue === 'placeholder').length} |

### Details

${Object.entries(byType).map(([type, typeIssues]) => `
#### ${type.charAt(0).toUpperCase() + type.slice(1)}s

| Title | Issue | Words | URL |
|-------|-------|-------|-----|
${typeIssues.map(i => `| ${i.title} | ${i.issue} | ${i.wordCount} | \`${i.url}\` |`).join('\n')}
`).join('\n')}
`;

    // Append to inventory
    const existing = await fs.readFile('docs/content/sitemap-inventory.md', 'utf-8');
    await fs.writeFile('docs/content/sitemap-inventory.md', existing + markdown);

    console.log('\n\nIssues appended to docs/content/sitemap-inventory.md');
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  } finally {
    await db.$disconnect();
  }
}

main();
```

**Step 2: Run the script**

```bash
pnpm tsx scripts/find-empty-content.ts
```

**Step 3: Commit**

```bash
git add scripts/find-empty-content.ts docs/content/sitemap-inventory.md
git commit -m "feat: add empty content detection, update inventory"
```

---

## Task 5: Final Review and Push

**Step 1: Verify all files**

```bash
ls -la docs/content/
cat docs/content/sitemap-inventory.md | head -100
```

**Step 2: Run any final checks**

```bash
pnpm type-check
```

**Step 3: Push to origin**

```bash
git push origin main
```

---

## Summary

| Task | Description | Output |
|------|-------------|--------|
| 1 | Create content directory | `docs/content/README.md` |
| 2 | Create inventory script | `scripts/content-inventory.ts` |
| 3 | Run and review inventory | `docs/content/sitemap-inventory.md` |
| 4 | Find empty content | Issues appended to inventory |
| 5 | Final review and push | Code pushed to origin |

## Files Created

- `docs/content/README.md` - Directory index
- `docs/content/sitemap-inventory.md` - Full content inventory
- `scripts/content-inventory.ts` - Inventory generation script
- `scripts/find-empty-content.ts` - Empty content finder

## Gate Criteria

‚úÖ Complete inventory with counts for all content types
‚úÖ Route mapping for public and admin
‚úÖ Content status assessment (complete/partial/empty)
‚úÖ Issues identified and documented
